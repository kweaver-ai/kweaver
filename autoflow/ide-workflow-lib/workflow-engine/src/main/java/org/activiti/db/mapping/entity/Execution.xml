<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.activiti.engine.impl.persistence.entity.ExecutionEntity">

  <!-- EXECUTION INSERT -->

  <insert id="insertExecution" parameterType="org.activiti.engine.impl.persistence.entity.ExecutionEntity">
    insert into ${prefix}t_wf_ru_execution (id_, rev_, proc_inst_id_, business_key_, proc_def_id_, act_id_, is_active_, is_concurrent_, is_scope_,is_event_scope_, parent_id_, super_exec_, suspension_state_, cached_ent_state_, tenant_id_, name_,top_process_instance_id_)
    values (
      #{id ,jdbcType=VARCHAR},
      1,
      #{processInstanceId, jdbcType=VARCHAR},
      #{businessKey, jdbcType=VARCHAR},
      #{processDefinitionId ,jdbcType=VARCHAR},
      #{activityId ,jdbcType=VARCHAR},
      #{isActive ,jdbcType=BOOLEAN},
      #{isConcurrent ,jdbcType=BOOLEAN},
      #{isScope ,jdbcType=BOOLEAN},
      #{isEventScope ,jdbcType=BOOLEAN},
      #{parentId, jdbcType=VARCHAR},
      #{superExecutionId, jdbcType=VARCHAR},
      #{suspensionState, jdbcType=INTEGER},
      #{cachedEntityState, jdbcType=INTEGER},
      #{tenantId, jdbcType=VARCHAR},
      #{name, jdbcType=VARCHAR},#{topProcessInstanceId, jdbcType=VARCHAR}
    )
  </insert>

  <insert id="bulkInsertExecution" parameterType="java.util.List">
    insert into ${prefix}t_wf_ru_execution (id_, rev_, proc_inst_id_, business_key_, proc_def_id_, act_id_, is_active_, is_concurrent_, is_scope_,is_event_scope_, parent_id_, super_exec_, suspension_state_, cached_ent_state_, tenant_id_, name_,top_process_instance_id_)
    values
      <foreach collection="list" item="execution" index="index" separator=",">
        (#{execution.id ,jdbcType=VARCHAR},
         1,
         #{execution.processInstanceId, jdbcType=VARCHAR},
         #{execution.businessKey, jdbcType=VARCHAR},
         #{execution.processDefinitionId ,jdbcType=VARCHAR},
         #{execution.activityId ,jdbcType=VARCHAR},
         #{execution.isActive ,jdbcType=BOOLEAN},
         #{execution.isConcurrent ,jdbcType=BOOLEAN},
         #{execution.isScope ,jdbcType=BOOLEAN},
         #{execution.isEventScope ,jdbcType=BOOLEAN},
         #{execution.parentId, jdbcType=VARCHAR},
         #{execution.superExecutionId, jdbcType=VARCHAR},
         #{execution.suspensionState, jdbcType=INTEGER},
         #{execution.cachedEntityState, jdbcType=INTEGER},
         #{execution.tenantId, jdbcType=VARCHAR},
         #{execution.name, jdbcType=VARCHAR},
         #{execution.topProcessInstanceId, jdbcType=VARCHAR}
         )
      </foreach>
  </insert>

  <insert id="bulkInsertExecution_oracle" parameterType="java.util.List">
    INSERT ALL
      <foreach collection="list" item="execution" index="index">
        into ${prefix}t_wf_ru_execution (id_, rev_, proc_inst_id_, business_key_, proc_def_id_, act_id_,
        is_active_, is_concurrent_, is_scope_,is_event_scope_, parent_id_, super_exec_, suspension_state_, cached_ent_state_, tenant_id_, name_, top_process_instance_id_) values
            (#{execution.id ,jdbcType=VARCHAR},
             1,
             #{execution.processInstanceId, jdbcType=VARCHAR},
             #{execution.businessKey, jdbcType=VARCHAR},
             #{execution.processDefinitionId ,jdbcType=VARCHAR},
             #{execution.activityId ,jdbcType=VARCHAR},
             #{execution.isActive ,jdbcType=BOOLEAN},
             #{execution.isConcurrent ,jdbcType=BOOLEAN},
             #{execution.isScope ,jdbcType=BOOLEAN},
             #{execution.isEventScope ,jdbcType=BOOLEAN},
             #{execution.parentId, jdbcType=VARCHAR},
             #{execution.superExecutionId, jdbcType=VARCHAR},
             #{execution.suspensionState, jdbcType=INTEGER},
             #{execution.cachedEntityState, jdbcType=INTEGER},
             #{execution.tenantId, jdbcType=VARCHAR},
             #{execution.name, jdbcType=VARCHAR},
             #{execution.topProcessInstanceId, jdbcType=VARCHAR}
             )
      </foreach>
    SELECT * FROM dual
  </insert>

  <!-- EXECUTION UPDATE -->

  <update id="updateExecution" parameterType="org.activiti.engine.impl.persistence.entity.ExecutionEntity">
    update ${prefix}t_wf_ru_execution set
      rev_ = #{revisionNext, jdbcType=INTEGER},
      business_key_ = #{businessKey, jdbcType=VARCHAR},
      proc_def_id_ = #{processDefinitionId, jdbcType=VARCHAR},
      act_id_ = #{activityId, jdbcType=VARCHAR},
      is_active_ = #{isActive, jdbcType=BOOLEAN},
      is_concurrent_ = #{isConcurrent, jdbcType=BOOLEAN},
      is_scope_ = #{isScope, jdbcType=BOOLEAN},
      is_event_scope_ = #{isEventScope, jdbcType=BOOLEAN},
      parent_id_ = #{parentId, jdbcType=VARCHAR},
      super_exec_ = #{superExecutionId, jdbcType=VARCHAR},
      suspension_state_ = #{suspensionState, jdbcType=INTEGER},
      cached_ent_state_ = #{cachedEntityState, jdbcType=INTEGER},
      name_ = #{name, jdbcType=VARCHAR}
    where id_ = #{id, jdbcType=VARCHAR}
      and rev_ = #{revision, jdbcType=INTEGER}
  </update>

  <update id="updateExecutionTenantIdForDeployment" parameterType="java.util.Map">
    update ${prefix}t_wf_ru_execution set
      tenant_id_ = #{tenantId, jdbcType=VARCHAR}
    where
      id_ in (
        select e.id_ from ${prefix}t_wf_ru_execution e
        inner join ${prefix}t_wf_re_procdef p on e.proc_def_id_  = p.id_
        inner join ${prefix}t_wf_re_deployment d on p.deployment_id_ = d.id_
        where d.id_ = #{deploymentId, jdbcType=VARCHAR}
      )
  </update>

  <!-- See http://stackoverflow.com/questions/4429319/you-cant-specify-target-table-for-update-in-from-clause
       Tested this on MySQL 5.6: does NOT use a temporary table (so good, performance0 -->
  <update id="updateExecutionTenantIdForDeployment_mysql" parameterType="java.util.Map">
    update ${prefix}t_wf_ru_execution set
      tenant_id_ = #{tenantId, jdbcType=VARCHAR}
    where
      id_ in (

          select tempExecution.tempId
          from (
                select e.id_ as tempid
                from  ${prefix}t_wf_ru_execution e
                inner join ${prefix}t_wf_re_procdef p on e.proc_def_id_  = p.id_
                inner join ${prefix}t_wf_re_deployment d on p.deployment_id_ = d.id_
                where d.id_ = #{deploymentId, jdbcType=VARCHAR}

        ) AS tempExecution

    )
  </update>

  <update id="updateProcessInstanceLockTime" parameterType="java.util.Map">
    update ${prefix}t_wf_ru_execution
    set
      lock_time_ = #{lockTime, jdbcType=TIMESTAMP}
    where id_ = #{id}
      and (lock_time_ is null or lock_time_ &lt; #{expirationTime, jdbcType=TIMESTAMP})
  </update>

  <update id="clearProcessInstanceLockTime" parameterType="java.util.Map">
    update ${prefix}t_wf_ru_execution
    set
      lock_time_ = null
    where id_ = #{id}
  </update>

  <!-- EXECUTION DELETE -->

  <delete id="deleteExecution" parameterType="org.activiti.engine.impl.persistence.entity.ExecutionEntity">
    delete from ${prefix}t_wf_ru_execution where id_ = #{id} and rev_ = #{revision}
  </delete>

  <!-- EXECUTION RESULTMAP -->

  <resultMap id="executionResultMap" type="org.activiti.engine.impl.persistence.entity.ExecutionEntity">
    <id property="id" column="id_" jdbcType="VARCHAR" />
    <result property="revision" column="rev_" jdbcType="INTEGER" />
    <result property="processInstanceId" column="proc_inst_id_" jdbcType="VARCHAR" />
    <result property="businessKey" column="business_key_" jdbcType="VARCHAR" />
    <result property="processDefinitionId" column="PROC_DEF_ID_" jdbcType="VARCHAR" />
    <result property="activityId" column="act_id_" jdbcType="VARCHAR" />
    <result property="isActive" column="is_active_" jdbcType="BOOLEAN" />
    <result property="isConcurrent" column="is_concurrent_" jdbcType="BOOLEAN" />
    <result property="isScope" column="is_scope_" jdbcType="BOOLEAN" />
    <result property="isEventScope" column="is_event_scope_" jdbcType="BOOLEAN" />
    <result property="parentId" column="parent_id_" jdbcType="VARCHAR" />
    <result property="superExecutionId" column="super_exec_" jdbcType="VARCHAR" />
    <result property="suspensionState" column="suspension_state_" jdbcType="INTEGER"/>
    <result property="cachedEntityState" column="cached_ent_state_" jdbcType="INTEGER"/>
    <result property="tenantId" column="tenant_id_" jdbcType="VARCHAR" />
    <result property="name" column="name_" jdbcType="VARCHAR" />
    <!--extend table columns by lw start -->
    <result property="topProcessInstanceId" column="top_process_instance_id_" jdbcType="VARCHAR" />

  </resultMap>

  <resultMap id="processInstanceResultMap" type="org.activiti.engine.impl.persistence.entity.ExecutionEntity">
    <id property="id" column="id_" jdbcType="VARCHAR" />
    <result property="revision" column="rev_" jdbcType="INTEGER" />
    <result property="processInstanceId" column="proc_inst_id_" jdbcType="VARCHAR" />
    <result property="businessKey" column="business_key_" jdbcType="VARCHAR" />

    <!-- Lowercase 'columns', as they are filled in during a query and are not mapped directly to a table column -->
    <result property="processDefinitionId" column="proc_def_id_" jdbcType="VARCHAR" />
    <result property="processDefinitionName" column="ProcessDefinitionName" jdbcType="VARCHAR" />
    <result property="processDefinitionKey" column="ProcessDefinitionKey" jdbcType="VARCHAR" />
    <result property="processDefinitionVersion" column="ProcessDefinitionVersion" jdbcType="INTEGER" />
    <result property="deploymentId" column="deploymentid" jdbcType="VARCHAR" />

    <result property="activityId" column="act_id_" jdbcType="VARCHAR" />
    <result property="isActive" column="is_active_" jdbcType="BOOLEAN" />
    <result property="isConcurrent" column="is_concurrent_" jdbcType="BOOLEAN" />
    <result property="isScope" column="is_scope_" jdbcType="BOOLEAN" />
    <result property="isEventScope" column="is_event_scope_" jdbcType="BOOLEAN" />
    <result property="parentId" column="parent_id_" jdbcType="VARCHAR" />
    <result property="superExecutionId" column="super_exec_" jdbcType="VARCHAR" />
    <result property="suspensionState" column="suspension_state_" jdbcType="INTEGER"/>
    <result property="cachedEntityState" column="cached_ent_state_" jdbcType="INTEGER"/>
    <result property="tenantId" column="tenant_id_" jdbcType="VARCHAR" />
    <result property="name" column="name_" jdbcType="VARCHAR" />
    <result property="lockTime" column="lock_time_" jdbcType="TIMESTAMP" />
    <!--extend table columns by lw start -->
    <result property="topProcessInstanceId" column="top_process_instance_id_" jdbcType="VARCHAR" />

  </resultMap>

  <resultMap id="executionAndVariablesResultMap" type="org.activiti.engine.impl.persistence.entity.ExecutionEntity">
    <id property="id" column="id_" jdbcType="VARCHAR" />
    <result property="revision" column="rev_" jdbcType="INTEGER" />
    <result property="processInstanceId" column="proc_inst_id_" jdbcType="VARCHAR" />
    <result property="businessKey" column="business_key_" jdbcType="VARCHAR" />
    <result property="processDefinitionId" column="proc_def_id_" jdbcType="VARCHAR" />
    <result property="activityId" column="act_id_" jdbcType="VARCHAR" />
    <result property="isActive" column="is_active_" jdbcType="BOOLEAN" />
    <result property="isConcurrent" column="is_concurrent_" jdbcType="BOOLEAN" />
    <result property="isScope" column="is_scope_" jdbcType="BOOLEAN" />
    <result property="isEventScope" column="is_event_scope_" jdbcType="BOOLEAN" />
    <result property="parentId" column="parent_id_" jdbcType="VARCHAR" />
    <result property="superExecutionId" column="super_exec_" jdbcType="VARCHAR" />
    <result property="suspensionState" column="suspension_state_" jdbcType="INTEGER"/>
    <result property="cachedEntityState" column="cached_ent_state_" jdbcType="INTEGER"/>
    <result property="tenantId" column="tenant_id_" jdbcType="VARCHAR" />
    <result property="name" column="name_" jdbcType="VARCHAR" />
    <!--extend table columns by lw start -->
    <result property="topProcessInstanceId" column="top_process_instance_id_" jdbcType="VARCHAR" />
    <collection property="queryVariables" column="execution_id_" javaType="ArrayList" ofType="org.activiti.engine.impl.persistence.entity.VariableInstanceEntity">
      <id property="id" column="VAR_ID_"/>
      <result property="name" column="var_name_" javaType="String" jdbcType="VARCHAR" />
      <result property="type" column="var_type_" javaType="org.activiti.engine.impl.variable.VariableType" jdbcType="VARCHAR" />
      <result property="revision" column="var_rev_" jdbcType="INTEGER" />
      <result property="processInstanceId" column="var_proc_inst_id_" jdbcType="VARCHAR" />
      <result property="executionId" column="var_execution_id_" jdbcType="VARCHAR" />
      <result property="taskId" column="var_task_id_" jdbcType="VARCHAR" />
      <result property="byteArrayRef" column="var_bytearray_id_" typeHandler="ByteArrayRefTypeHandler"/>
      <result property="doubleValue" column="var_double_" jdbcType="DOUBLE" />
      <result property="textValue" column="var_text_" jdbcType="VARCHAR" />
      <result property="textValue2" column="var_text2_" jdbcType="VARCHAR" />
      <result property="longValue" column="var_long_" jdbcType="BIGINT" />
    </collection>
  </resultMap>

  <resultMap id="processInstanceAndVariablesResultMap" type="org.activiti.engine.impl.persistence.entity.ExecutionEntity">
    <id property="id" column="id_" jdbcType="VARCHAR" />
    <result property="revision" column="rev_" jdbcType="INTEGER" />
    <result property="processInstanceId" column="proc_inst_id_" jdbcType="VARCHAR" />
    <result property="businessKey" column="business_key_" jdbcType="VARCHAR" />
    <result property="processDefinitionId" column="proc_def_id_" jdbcType="VARCHAR" />
    <result property="processDefinitionName" column="processdefinitionname" jdbcType="VARCHAR" />
    <result property="processDefinitionKey" column="processdefinitionkey" jdbcType="VARCHAR" />
    <result property="processDefinitionVersion" column="processdefinitionversion" jdbcType="INTEGER" />
    <result property="deploymentId" column="deploymentid" jdbcType="VARCHAR" />
    <result property="activityId" column="act_id_" jdbcType="VARCHAR" />
    <result property="isActive" column="is_active_" jdbcType="BOOLEAN" />
    <result property="isConcurrent" column="is_concurrent_" jdbcType="BOOLEAN" />
    <result property="isScope" column="is_scope_" jdbcType="BOOLEAN" />
    <result property="isEventScope" column="is_event_scope_" jdbcType="BOOLEAN" />
    <result property="parentId" column="parent_id_" jdbcType="VARCHAR" />
    <result property="superExecutionId" column="super_exec_" jdbcType="VARCHAR" />
    <result property="suspensionState" column="suspension_state_" jdbcType="INTEGER"/>
    <result property="cachedEntityState" column="cached_ent_state_" jdbcType="INTEGER"/>
    <result property="tenantId" column="tenant_id_" jdbcType="VARCHAR" />
    <result property="name" column="name_" jdbcType="VARCHAR" />
    <result property="lockTime" column="lock_time_" jdbcType="TIMESTAMP" />
    <!--extend table columns by lw start -->
    <result property="topProcessInstanceId" column="top_process_instance_id_" jdbcType="VARCHAR" />
    <collection property="queryVariables" column="execution_id_" javaType="ArrayList" ofType="org.activiti.engine.impl.persistence.entity.VariableInstanceEntity">
      <id property="id" column="VAR_ID_"/>
      <result property="name" column="var_name_" javaType="String" jdbcType="VARCHAR" />
      <result property="type" column="var_type_" javaType="org.activiti.engine.impl.variable.VariableType" jdbcType="VARCHAR" />
      <result property="revision" column="var_rev_" jdbcType="INTEGER" />
      <result property="processInstanceId" column="var_proc_inst_id_" jdbcType="VARCHAR" />
      <result property="executionId" column="var_execution_id_" jdbcType="VARCHAR" />
      <result property="taskId" column="var_task_id_" jdbcType="VARCHAR" />
      <result property="byteArrayRef" column="var_bytearray_id_" typeHandler="ByteArrayRefTypeHandler"/>
      <result property="doubleValue" column="var_double_" jdbcType="DOUBLE" />
      <result property="textValue" column="var_text_" jdbcType="VARCHAR" />
      <result property="textValue2" column="var_text2_" jdbcType="VARCHAR" />
      <result property="longValue" column="var_long_" jdbcType="BIGINT" />
    </collection>
  </resultMap>

  <!-- EXECUTION SELECT -->

  <select id="selectExecution" parameterType="string" resultMap="executionResultMap">
    select * from ${prefix}t_wf_ru_execution where id_ = #{id}
  </select>

  <select id="selectExecutionsByParentExecutionId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="executionResultMap">
    select * from ${prefix}t_wf_ru_execution
    where PARENT_ID_ = #{parameter}
  </select>

  <select id="selectExecutionsByProcessInstanceId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="executionResultMap">
    select * from ${prefix}t_wf_ru_execution
    where PROC_INST_ID_ = #{parameter}
  </select>

  <select id="selectProcessInstanceIdsByProcessDefinitionId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultType="string">
    select id_
    from ${prefix}t_wf_ru_execution
    where proc_def_id_ = #{parameter} and parent_id_ is null
  </select>

  <select id="selectExecutionsByQueryCriteria" parameterType="org.activiti.engine.impl.ExecutionQueryImpl" resultMap="executionResultMap">
  	${limitBefore}
    select RES.* ${limitBetween}, p.key_ as ProcessDefinitionKey, p.id_ as ProcessDefinitionId
    <include refid="selectExecutionsByQueryCriteriaSql"/>
    ${orderBy}
    ${limitAfter}
  </select>

  <select id="selectExecutionCountByQueryCriteria" parameterType="org.activiti.engine.impl.ExecutionQueryImpl" resultType="long">
    select distinct count(RES.id_)
    <include refid="selectExecutionsByQueryCriteriaSql"/>
  </select>

  <!--  same as selectExecutionsByQueryCriteria, but with different parameterType -->
  <select id="selectProcessInstanceByQueryCriteria" parameterType="org.activiti.engine.impl.ProcessInstanceQueryImpl" resultMap="processInstanceResultMap">
  	${limitBefore}
    select RES.* ${limitBetween}, p.key_ as ProcessDefinitionKey, p.id_ as ProcessDefinitionId, p.name_ as ProcessDefinitionName, p.version_ as ProcessDefinitionVersion, p.deployment_id_ as DeploymentId
    <include refid="selectExecutionsByQueryCriteriaSql"/>
    ${orderBy}
    ${limitAfter}
  </select>

  <select id="selectProcessInstanceCountByQueryCriteria" parameterType="org.activiti.engine.impl.ProcessInstanceQueryImpl" resultType="long">
    select count(distinct RES.id_)
    <include refid="selectExecutionsByQueryCriteriaSql"/>
  </select>

  <sql id="selectExecutionsByQueryCriteriaSql">
    from ${prefix}t_wf_ru_execution RES
    inner join ${prefix}t_wf_re_procdef p on RES.proc_def_id_ = p.id_
    <include refid="commonSelectExecutionsByQueryCriteriaSql"/>
  </sql>

  <select id="selectProcessInstanceWithVariablesByQueryCriteria" parameterType="org.activiti.engine.impl.ProcessInstanceQueryImpl" resultMap="processInstanceAndVariablesResultMap">
    ${limitBefore}
    select RES.*, p.key_ as ProcessDefinitionKey, p.id_ as ProcessDefinitionId, p.name_ as ProcessDefinitionName, p.version_ as ProcessDefinitionVersion, p.deployment_id_ as DeploymentId,
    var.id_ as VAR_ID_, var.name_ as VAR_NAME_, var.type_ as VAR_TYPE_, var.rev_ as VAR_REV_,
    var.proc_inst_id_ as VAR_PROC_INST_ID_, var.execution_id_ as VAR_EXECUTION_ID_, var.task_id_ as VAR_TASK_ID_,
    var.bytearray_id_ as VAR_BYTEARRAY_ID_, var.double_ as VAR_DOUBLE_,
    var.text_ as VAR_TEXT_, var.text2_ as VAR_TEXT2_, var.long_ as VAR_LONG_
    ${limitBetween}
    <include refid="selectProcessInstanceWithVariablesByQueryCriteriaSql"/>
    ${orderBy}
    ${limitAfter}
  </select>

  <select id="selectProcessInstanceWithVariablesByQueryCriteria_mssql_or_db2" parameterType="org.activiti.engine.impl.ProcessInstanceQueryImpl" resultMap="processInstanceAndVariablesResultMap">
    ${limitBefore}
    select distinct TEMPRES_ID_ as ID_, TEMPP_KEY_ as ProcessDefinitionKey, TEMPP_ID_ as ProcessDefinitionId, TEMPP_NAME_ as ProcessDefinitionName, TEMPP_VERSION_ as ProcessDefinitionVersion, TEMPP_DEPLOYMENT_ID_ as DeploymentId,
    TEMPRES_REV_ as REV_, TEMPRES_ACT_ID_ as ACT_ID_,
    TEMPRES_BUSINESS_KEY_ as BUSINESS_KEY_, TEMPRES_IS_ACTIVE_ as IS_ACTIVE_,
    TEMPRES_IS_CONCURRENT_ as IS_CONCURRENT_, TEMPRES_IS_SCOPE_ as IS_SCOPE_,
    TEMPRES_IS_EVENT_SCOPE_ as IS_EVENT_SCOPE_, TEMPRES_PARENT_ID_ as PARENT_ID_,
    TEMPRES_PROC_INST_ID_ as PROC_INST_ID_, TEMPRES_SUPER_EXEC_ as SUPER_EXEC_,
    TEMPRES_PROC_DEF_ID_ as PROC_DEF_ID_, TEMPRES_NAME_ as NAME_, TEMPRES_TENANT_ID_ as TENANT_ID_,
    TEMPRES_SUSPENSION_STATE_ as SUSPENSION_STATE_, TEMPRES_CACHED_ENT_STATE_ as CACHED_ENT_STATE_,
    TEMPVAR_ID_ as VAR_ID_, TEMPVAR_NAME_ as VAR_NAME_, TEMPVAR_TYPE_ as VAR_TYPE_, TEMPVAR_REV_ as VAR_REV_,
    TEMPVAR_PROC_INST_ID_ as VAR_PROC_INST_ID_, TEMPVAR_EXECUTION_ID_ as VAR_EXECUTION_ID_, TEMPVAR_TASK_ID_ as VAR_TASK_ID_,
    TEMPVAR_BYTEARRAY_ID_ as VAR_BYTEARRAY_ID_, TEMPVAR_DOUBLE_ as VAR_DOUBLE_,
    TEMPVAR_TEXT_ as VAR_TEXT_, TEMPVAR_TEXT2_ as VAR_TEXT2_, TEMPVAR_LONG_ as VAR_LONG_
    ${limitOuterJoinBetween}
    RES.ID_ as TEMPRES_ID_, RES.REV_ as TEMPRES_REV_, P.KEY_ as TEMPP_KEY_, P.ID_ as TEMPP_ID_, P.NAME_ as TEMPP_NAME_, P.VERSION_ as TEMPP_VERSION_, P.DEPLOYMENT_ID_ as TEMPP_DEPLOYMENT_ID_,
    RES.ACT_ID_ as TEMPRES_ACT_ID_, RES.PROC_INST_ID_ as TEMPRES_PROC_INST_ID_,
    RES.BUSINESS_KEY_ as TEMPRES_BUSINESS_KEY_, RES.IS_ACTIVE_ as TEMPRES_IS_ACTIVE_,
    RES.IS_CONCURRENT_ as TEMPRES_IS_CONCURRENT_, RES.IS_SCOPE_ as TEMPRES_IS_SCOPE_,
    RES.IS_EVENT_SCOPE_ as TEMPRES_IS_EVENT_SCOPE_, RES.PARENT_ID_ as TEMPRES_PARENT_ID_,
    RES.SUPER_EXEC_ as TEMPRES_SUPER_EXEC_, RES.SUSPENSION_STATE_ as TEMPRES_SUSPENSION_STATE_,
    RES.CACHED_ENT_STATE_ as TEMPRES_CACHED_ENT_STATE_,
    RES.PROC_DEF_ID_ as TEMPRES_PROC_DEF_ID_, RES.NAME_ as TEMPRES_NAME_, RES.TENANT_ID_ as TEMPRES_TENANT_ID_,
    VAR.ID_ as TEMPVAR_ID_, VAR.NAME_ as TEMPVAR_NAME_, VAR.TYPE_ as TEMPVAR_TYPE_, VAR.REV_ as TEMPVAR_REV_,
    VAR.PROC_INST_ID_ as TEMPVAR_PROC_INST_ID_, VAR.EXECUTION_ID_ as TEMPVAR_EXECUTION_ID_, VAR.TASK_ID_ as TEMPVAR_TASK_ID_,
    VAR.BYTEARRAY_ID_ as TEMPVAR_BYTEARRAY_ID_, VAR.DOUBLE_ as TEMPVAR_DOUBLE_,
    VAR.TEXT_ as TEMPVAR_TEXT_, VAR.TEXT2_ as TEMPVAR_TEXT2_, VAR.LONG_ as TEMPVAR_LONG_
    <include refid="selectProcessInstanceWithVariablesByQueryCriteriaSql"/>
    ${orderBy}
    ${limitAfter}
  </select>

  <sql id="selectProcessInstanceWithVariablesByQueryCriteriaSql">
    from ${prefix}t_wf_ru_execution RES
    inner join ${prefix}t_wf_re_procdef p on RES.proc_def_id_ = p.id_
    <if test="includeProcessVariables">
      left outer join ${prefix}t_wf_ru_variable var on RES.proc_inst_id_ = var.execution_id_ and var.task_id_ is null
    </if>
    <include refid="commonSelectExecutionsByQueryCriteriaSql"/>
  </sql>

  <sql id="commonSelectExecutionsByQueryCriteriaSql">
    <foreach collection="queryVariableValues" index="index" item="queryVariableValue">
      <choose>
        <when test="queryVariableValue.local">
          inner join ${prefix}t_wf_ru_variable a${index} on RES.id_ = a${index}.execution_id_
        </when>
        <otherwise>
          inner join ${prefix}t_wf_ru_variable a${index} on RES.proc_inst_id_ = a${index}.proc_inst_id_
        </otherwise>
      </choose>
    </foreach>
    <foreach collection="orQueryObjects" index="orIndex" item="orQueryObject">
      <if test="orQueryObject.processDefinitionId != null || orQueryObject.processDefinitionKey != null || orQueryObject.processDefinitionVersion != null || orQueryObject.processDefinitionCategory != null || orQueryObject.processDefinitionName != null || (orQueryObject.processDefinitionIds != null &amp;&amp; !orQueryObject.processDefinitionIds.isEmpty()) || (orQueryObject.processDefinitionKeys != null &amp;&amp; !orQueryObject.processDefinitionKeys.isEmpty())">
        inner join ${prefix}t_wf_re_procdef p_or${orIndex} on RES.proc_def_id_ = p_or${orIndex}.id_
      </if>
      <if test="orQueryObject.queryVariableValues != null &amp;&amp; orQueryObject.queryVariableValues.size() &gt; 0">
        left outer join ${prefix}t_wf_ru_variable a_or${orIndex} on RES.proc_inst_id_ = a_or${orIndex}.proc_inst_id_
      </if>
      <if test="orQueryObject.deploymentId != null || (orQueryObject.deploymentIds != null &amp;&amp; orQueryObject.deploymentIds.size() &gt; 0)">
        left outer join ${prefix}t_wf_re_procdef deploy_p_or${orIndex} on RES.proc_def_id_ = deploy_p_or${orIndex}.id_
      </if>
    </foreach>
    <if test="eventSubscriptions != null">
      <foreach collection="eventSubscriptions" index="index" item="eventSubscriptionValue">
    	inner join ${prefix}t_wf_ru_event_subscr evt${index} on RES.id_ = evt${index}.execution_id_
	   </foreach>
    </if>
    <if test="businessKey != null and includeChildExecutionsWithBusinessKeyQuery">
        inner join ${prefix}t_wf_ru_execution inst on RES.proc_inst_id_ = inst.id_
    </if>
    <if test="deploymentId != null || (deploymentIds != null &amp;&amp; deploymentIds.size() &gt; 0)">
      left outer join ${prefix}t_wf_re_procdef deploy_p on RES.proc_def_id_ = deploy_p.id_
    </if>
    <if test="onlyProcessInstances &amp;&amp; withJobException">
      left outer join ${prefix}t_wf_ru_job job on RES.proc_inst_id_ = job.process_instance_id_
    </if>
    <where>
      <if test="onlyProcessInstances">
        RES.parent_id_ is null
      </if>
      <if test="processDefinitionId != null">
        and p.id_ = #{processDefinitionId}
      </if>
      <if test="processDefinitionIds != null and !processDefinitionIds.isEmpty()">
        and p.id_ in
        <foreach item="item" index="index" collection="processDefinitionIds" open="(" separator="," close=")">
          #{item}
        </foreach>
      </if>
      <if test="processDefinitionKey != null">
        and p.key_ = #{processDefinitionKey}
      </if>
      <if test="processDefinitionKeys != null and !processDefinitionKeys.isEmpty()">
        and p.key_ in
        <foreach item="item" index="index" collection="processDefinitionKeys" open="(" separator="," close=")">
          #{item}
        </foreach>
      </if>
      <if test="processDefinitionCategory != null">
        and p.category_ = #{processDefinitionCategory}
      </if>
      <if test="processDefinitionName != null">
        and p.name_ = #{processDefinitionName}
      </if>
      <if test="processDefinitionVersion != null">
        and p.version_ = #{processDefinitionVersion}
      </if>
      <if test="executionId != null">
        and RES.id_ = #{executionId}
      </if>
      <if test="processInstanceId != null">
        and RES.proc_inst_id_ = #{processInstanceId}
      </if>
      <if test="processInstanceIds != null and !processInstanceIds.isEmpty()">
        and RES.proc_inst_id_ in
        <foreach item="item" index="index" collection="processInstanceIds" open="(" separator="," close=")">
          #{item}
        </foreach>
      </if>
      <if test="businessKey != null and !includeChildExecutionsWithBusinessKeyQuery">
        and RES.business_key_ = #{businessKey}
      </if>
      <if test="businessKey != null and includeChildExecutionsWithBusinessKeyQuery">
        and inst.business_key_ = #{businessKey}
      </if>
      <if test="activityId != null">
        and RES.act_id_ = #{activityId} and RES.IS_ACTIVE_ = #{isActive}
      </if>
      <if test="parentId != null">
        and RES.parent_id_ = #{parentId}
      </if>
      <if test="deploymentId != null">
        and deploy_p.deployment_id_ = #{deploymentId}
      </if>
      <if test="deploymentIds != null &amp;&amp; deploymentIds.size() &gt; 0">
        and deploy_p.deployment_id_ in
        <foreach item="deployment" index="index" collection="deploymentIds"
                 open="(" separator="," close=")">
          #{deployment}
        </foreach>
      </if>
      <if test="superProcessInstanceId != null">
        <!-- A sub process instance is stored under a certain *execution*, potentially nested.
             A sub process instance is NOT stored under the process instanc, hence the following: -->
        and RES.super_exec_ in (select id_ from ${prefix}t_wf_ru_execution where proc_inst_id_ = #{superProcessInstanceId})
      </if>
      <if test="subProcessInstanceId != null">
        and RES.id_ = (select proc_inst_id_ from ${prefix}t_wf_ru_execution where id_ = (select super_exec_ from ${prefix}t_wf_ru_execution where id_ = #{subProcessInstanceId}))
      </if>
      <if test="excludeSubprocesses">
        and RES.super_exec_ is null
      </if>
      <if test="suspensionState != null">
      	<if test="suspensionState.stateCode == 1">
        	and (RES.suspension_state_ = 1)
        </if>
        <if test="suspensionState.stateCode == 2">
        	and (RES.suspension_state_ = 2)
        </if>
      </if>
      <if test="tenantId != null">
        and RES.tenant_id_ = #{tenantId}
      </if>
      <if test="tenantIdLike != null">
        and RES.tenant_id_ like #{tenantIdLike}${wildcardEscapeClause}
      </if>
      <if test="withoutTenantId">
        and (RES.tenant_id_ = '' or RES.tenant_id_ is null)
      </if>
      <if test="name != null">
        and RES.name_ = #{name}
      </if>
      <if test="nameLike != null">
        and RES.name_ like #{nameLike}${wildcardEscapeClause}
      </if>
       <if test="nameLikeIgnoreCase != null">
        and lower(RES.name_) like #{nameLikeIgnoreCase}${wildcardEscapeClause}
      </if>
      <if test="involvedUser != null">
        and exists(select ID_ from ${prefix}t_wf_ru_identitylink i where i.proc_inst_id_ = RES.id_ and i.user_id_ = #{involvedUser})
      </if>
      <!-- PLEASE NOTE: If you change anything have a look into the HistoricVariableInstance & HistoricProcessInstance, the same query object is used there! -->
      <foreach collection="queryVariableValues" index="index" item="queryVariableValue">
        <if test="!queryVariableValue.local">
          <!-- When process instance variable is queried for, only process variables are taken into account -->
          and a${index}.execution_id_ = a${index}.proc_inst_id_
        </if>
        <if test="queryVariableValue.name != null">
          <!-- Match-all variable-names when name is null -->
          and a${index}.name_= #{queryVariableValue.name}
        </if>
        <if test="!queryVariableValue.type.equals('null')">
        <!-- When operator is not-equals or type of value is null, type doesn't matter! -->
          and a${index}.type_ = #{queryVariableValue.type}
        </if>
      	<if test="queryVariableValue.textValue != null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
          <choose>
            <when test="queryVariableValue.operator.equals('EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">
              and lower(a${index}.text_)
            </when>
            <otherwise>
              and a${index}.text_
            </otherwise>
          </choose>
	      <choose>
	        <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">LIKE</when>
	        <otherwise><include refid="executionVariableOperator" /></otherwise>
	      </choose>
  	      #{queryVariableValue.textValue}
  	      <choose>
  	        <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">${wildcardEscapeClause}</when>
  	      </choose>
      	</if>
      	<if test="queryVariableValue.textValue2 != null">
	      and a${index}.text2_
	      <choose>
	        <when test="queryVariableValue.operator.equals('LIKE')">LIKE</when>
	        <otherwise><include refid="executionVariableOperator" /></otherwise>
	      </choose>
	        #{queryVariableValue.textValue2}
	      <choose>
	        <when test="queryVariableValue.operator.equals('LIKE')">${wildcardEscapeClause}</when>
	      </choose>
      	</if>
      	<if test="queryVariableValue.longValue != null">
	      and a${index}.long_
	      <include refid="executionVariableOperator" />
	      #{queryVariableValue.longValue}
      	</if>
      	<if test="queryVariableValue.doubleValue != null">
	      and a${index}.double_
	      <include refid="executionVariableOperator" />
	      #{queryVariableValue.doubleValue}
      	</if>
      	<!-- Null variable type -->
      	<if test="queryVariableValue.textValue == null &amp;&amp; queryVariableValue.textValue2 == null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
          <choose>
	        <when test="queryVariableValue.operator.equals('NOT_EQUALS')">
	          and (a${index}.text_ is not null or a${index}.text2_ is not null or a${index}.long_ is not null or a${index}.double_ is not null or a${index}.bytearray_id_ is not null)
	        </when>
	        <otherwise>
			  and a${index}.text_ is null and a${index}.text2_ is null and a${index}.long_ is null and a${index}.double_ is null and A${index}.bytearray_id_ is null
	        </otherwise>
	      </choose>
      	</if>
      </foreach>
      <!-- event subscriptions -->
      <if test="eventSubscriptions != null">
        <foreach collection="eventSubscriptions" index="index" item="eventSubscriptionValue">
    	    and (evt${index}.event_type_ = #{eventSubscriptionValue.eventType} and evt${index}.event_name_ = #{eventSubscriptionValue.eventName})
	      </foreach>
      </if>
      <foreach item="orQueryObject" index="orIndex" collection="orQueryObjects">
        and
        <trim prefix="(" prefixOverrides="OR" suffix=")">
          <if test="orQueryObject.processDefinitionId != null">
            p_or${orIndex}.id_ = #{orQueryObject.processDefinitionId}
          </if>
          <if test="orQueryObject.processDefinitionIds != null and !orQueryObject.processDefinitionIds.isEmpty()">
            or p_or${orIndex}.id_ in
            <foreach item="item" index="index" collection="orQueryObject.processDefinitionIds" open="(" separator="," close=")">
              #{item}
            </foreach>
          </if>
          <if test="orQueryObject.processDefinitionKey != null">
            or p_or${orIndex}.key_ = #{orQueryObject.processDefinitionKey}
          </if>
          <if test="orQueryObject.processDefinitionKeys != null and !orQueryObject.processDefinitionKeys.isEmpty()">
            or p_or${orIndex}.key_ in
            <foreach item="item" index="index" collection="orQueryObject.processDefinitionKeys" open="(" separator="," close=")">
              #{item}
            </foreach>
          </if>
          <if test="orQueryObject.processDefinitionCategory != null">
            or p_or${orIndex}.category_ = #{orQueryObject.processDefinitionCategory}
          </if>
          <if test="orQueryObject.processDefinitionName != null">
            or p_or${orIndex}.name_ = #{orQueryObject.processDefinitionName}
          </if>
          <if test="orQueryObject.processDefinitionVersion != null">
            or p_or${orIndex}.version_ = #{orQueryObject.processDefinitionVersion}
          </if>
          <if test="orQueryObject.executionId != null">
            or RES.id_ = #{orQueryObject.executionId}
          </if>
          <if test="orQueryObject.processInstanceId != null">
            or RES.proc_inst_id_ = #{orQueryObject.processInstanceId}
          </if>
          <if test="orQueryObject.processInstanceIds != null and !orQueryObject.processInstanceIds.isEmpty()">
            or RES.proc_inst_id_ in
            <foreach item="item" index="index" collection="orQueryObject.processInstanceIds" open="(" separator="," close=")">
              #{item}
            </foreach>
          </if>
          <if test="orQueryObject.businessKey != null">
            or RES.business_key_ = #{orQueryObject.businessKey}
          </if>
          <if test="orQueryObject.activityId != null">
            or (RES.act_id_ = #{orQueryObject.activityId} and RES.is_active_ = #{isActive})
          </if>
          <if test="orQueryObject.parentId != null">
            or RES.parent_id_ = #{orQueryObject.parentId}
          </if>
          <if test="orQueryObject.deploymentId != null">
            or deploy_p_or${orIndex}.deployment_id_ = #{orQueryObject.deploymentId}
          </if>
          <if test="orQueryObject.deploymentIds != null &amp;&amp; orQueryObject.deploymentIds.size() &gt; 0">
            or deploy_p_or${orIndex}.deployment_id_ in
            <foreach item="deployment" index="index" collection="orQueryObject.deploymentIds"
                     open="(" separator="," close=")">
              #{deployment}
            </foreach>
          </if>
          <if test="orQueryObject.superProcessInstanceId != null">
            <!-- A sub process instance is stored under a certain *execution*, potentially nested.
                 A sub process instance is NOT stored under the process instanc, hence the following: -->
            or RES.super_exec_ in (select id_ from ${prefix}t_wf_ru_execution where proc_inst_id_ = #{orQueryObject.superProcessInstanceId})
          </if>
          <if test="orQueryObject.subProcessInstanceId != null">
            or RES.id_ = (select proc_inst_id_ from ${prefix}t_wf_ru_execution where id_ = (select super_exec_ from ${prefix}t_wf_ru_execution where id_ = #{orQueryObject.subProcessInstanceId}))
          </if>
          <if test="orQueryObject.excludeSubprocesses">
            or RES.super_exec_ is null
          </if>
          <if test="orQueryObject.suspensionState != null">
            <if test="orQueryObject.suspensionState.stateCode == 1">
              or (RES.suspension_state_ = 1)
            </if>
            <if test="orQueryObject.suspensionState.stateCode == 2">
              or (RES.suspension_state_ = 2)
            </if>
          </if>
          <if test="orQueryObject.tenantId != null">
            or RES.tenant_id_ = #{orQueryObject.tenantId}
          </if>
          <if test="orQueryObject.tenantIdLike != null">
            or RES.tenant_id_ like #{orQueryObject.tenantIdLike}${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.withoutTenantId">
            or (RES.tenant_id_ = '' or RES.TENANT_ID_ is null)
          </if>
          <if test="orQueryObject.name != null">
            or RES.name_ = #{orQueryObject.name}
          </if>
          <if test="orQueryObject.nameLike != null">
            or RES.name_ like #{orQueryObject.nameLike}${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.nameLikeIgnoreCase != null">
            or lower(RES.name_) like #{orQueryObject.nameLikeIgnoreCase}${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.involvedUser != null">
            or exists(select id_ from ${prefix}t_wf_ru_identitylink i where i.proc_inst_id_ = RES.id_ and i.user_id_ = #{orQueryObject.involvedUser})
          </if>
          <!-- PLEASE NOTE: If you change anything have a look into the HistoricVariableInstance & HistoricProcessInstance, the same query object is used there! -->
          <foreach collection="orQueryObject.queryVariableValues" index="index" item="queryVariableValue">
            or
            <trim prefix="(" prefixOverrides="AND" suffix=")">
              <if test="!queryVariableValue.local">
                <!-- When process instance variable is queried for, only process variables are taken into account -->
                and a_or${orIndex}.execution_id_ = a_or${orIndex}.proc_inst_id_
              </if>
              <if test="queryVariableValue.name != null">
                <!-- Match-all variable-names when name is null -->
                and a_or${orIndex}.name_= #{queryVariableValue.name}
              </if>
              <if test="!queryVariableValue.type.equals('null')">
              <!-- When operator is not-equals or type of value is null, type doesn't matter! -->
                and a_or${orIndex}.type_ = #{queryVariableValue.type}
              </if>
              <if test="queryVariableValue.textValue != null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
                <choose>
                  <when test="queryVariableValue.operator.equals('EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">
                    and lower(a_or${orIndex}.text_)
                  </when>
                  <otherwise>
                    and a_or${orIndex}.text_
                  </otherwise>
                </choose>
              <choose>
                <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">LIKE</when>
                <otherwise><include refid="executionVariableOperator" /></otherwise>
              </choose>
                #{queryVariableValue.textValue}
              <choose>
                <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">${wildcardEscapeClause}</when>
              </choose>
              </if>
              <if test="queryVariableValue.textValue2 != null">
              and A_OR${orIndex}.text2_
              <choose>
                <when test="queryVariableValue.operator.equals('LIKE')">LIKE</when>
                <otherwise><include refid="executionVariableOperator" /></otherwise>
              </choose>
                #{queryVariableValue.textValue2}
                <choose>
                  <when test="queryVariableValue.operator.equals('LIKE')">${wildcardEscapeClause}</when>
                </choose>
              </if>
              <if test="queryVariableValue.longValue != null">
              and a_or${orIndex}.long_
              <include refid="executionVariableOperator" />
              #{queryVariableValue.longValue}
              </if>
              <if test="queryVariableValue.doubleValue != null">
              and a_or${orIndex}.double_
              <include refid="executionVariableOperator" />
              #{queryVariableValue.doubleValue}
              </if>
              <!-- Null variable type -->
              <if test="queryVariableValue.textValue == null &amp;&amp; queryVariableValue.textValue2 == null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
                <choose>
                  <when test="queryVariableValue.operator.equals('NOT_EQUALS')">
                    and (a_or${orIndex}.text_ is not null or a_or${orIndex}.text2_ is not null or a_or${orIndex}.long_ is not null or a_or${orIndex}.double_ is not null or a_or${orIndex}.bytearray_id_ is not null)
                  </when>
                  <otherwise>
                    and a_or${orIndex}.text_ is null and a_or${orIndex}.text2_ is null and a_or${orIndex}.long_ is null and a_or${orIndex}.double_ is null and a_or${orIndex}.bytearray_id_ is null
                  </otherwise>
                </choose>
              </if>
            </trim>
          </foreach>
        </trim>
      </foreach>
      <if test="onlyProcessInstances &amp;&amp; withJobException">
        and (job.exception_msg_ is not null or  job.exception_stack_id_ is not null)
      </if>
    </where>
  </sql>

  <sql id="executionVariableOperator">
    <choose>
   	  <when test="queryVariableValue.operator.equals('EQUALS')">=</when>
   	  <when test="queryVariableValue.operator.equals('EQUALS_IGNORE_CASE')">=</when>
   	  <when test="queryVariableValue.operator.equals('NOT_EQUALS')">&lt;&gt;</when>
   	  <when test="queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE')">&lt;&gt;</when>
   	  <when test="queryVariableValue.operator.equals('GREATER_THAN')">&gt;</when>
   	  <when test="queryVariableValue.operator.equals('GREATER_THAN_OR_EQUAL')">&gt;=</when>
   	  <when test="queryVariableValue.operator.equals('LESS_THAN')">&lt;</when>
   	  <when test="queryVariableValue.operator.equals('LESS_THAN_OR_EQUAL')">&lt;=</when>
   </choose>
  </sql>

  <select id="selectSubProcessInstanceBySuperExecutionId" parameterType="string" resultMap="executionResultMap">
    select *
    from ${prefix}t_wf_ru_execution
    where super_exec_ = #{parameter}
  </select>

  <select id="selectExecutionByNativeQuery" parameterType="java.util.Map" resultMap="executionResultMap">
  	<if test="resultType == 'LIST_PAGE'">
  		${limitBefore}
  	</if>
    ${sql}
    <if test="resultType == 'LIST_PAGE'">
    	${limitAfter}
    </if>
  </select>

  <select id="selectExecutionByNativeQuery_mssql_or_db2" parameterType="java.util.Map" resultMap="executionResultMap">
  	<if test="resultType == 'LIST_PAGE'">
        ${limitBeforeNativeQuery}
  	</if>
  	${sql}
    <if test="resultType == 'LIST_PAGE'">
  		${limitAfter}
  	</if>
  </select>

  <select id="selectExecutionCountByNativeQuery" parameterType="java.util.Map" resultType="long">
    ${sql}
  </select>
   <!-- by lw -->
  <select id="selectAllExecution" parameterType="org.activiti.engine.impl.ProcessInstanceQueryImpl" resultMap="executionResultMap">
  	select * from t_wf_ru_execution t where t.proc_inst_id_ in
	(select p.proc_inst_id_ from t_wf_hi_procinst p where  find_in_set(proc_inst_id_,
	(select getprocchildlst(t.top_process_instance_id_)  from t_wf_hi_procinst t where t.proc_inst_id_=#{processInstanceId} limit 1)
	))
  </select>

   <select id="getParentExecution" parameterType="org.activiti.engine.impl.ProcessInstanceQueryImpl" resultMap="executionResultMap">
   	select * from t_wf_ru_execution where parent_id_ = (select id_ from t_wf_ru_execution where parent_id_ = #{processInstanceId}))  limit 1
  </select>



</mapper>