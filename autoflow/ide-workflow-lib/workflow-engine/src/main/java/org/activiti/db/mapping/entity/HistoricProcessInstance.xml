<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntity">

  <!-- HISTORIC PROCESS INSTANCE INSERT -->

  <insert id="insertHistoricProcessInstance" parameterType="org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntity">
      insert into ${prefix}t_wf_hi_procinst (
        id_,
        proc_inst_id_,
        business_key_,
        proc_def_id_,
        start_time_,
        end_time_,
        duration_,
        start_user_id_,
        start_act_id_,
        end_act_id_,
        super_process_instance_id_,
        delete_reason_,
        tenant_id_,
        name_,
        proc_state,
        start_user_name,
        starter_org_id,
        starter_org_name,starter,top_process_instance_id_
      ) values (
        #{id ,jdbcType=VARCHAR},
        #{processInstanceId, jdbcType=VARCHAR},
        #{businessKey, jdbcType=VARCHAR},
        #{processDefinitionId, jdbcType=VARCHAR},
        #{startTime, jdbcType=TIMESTAMP},
        #{endTime, jdbcType=TIMESTAMP},
        #{durationInMillis ,jdbcType=BIGINT},
        #{startUserId, jdbcType=VARCHAR},
        #{startActivityId, jdbcType=VARCHAR},
        #{endActivityId, jdbcType=VARCHAR},
        #{superProcessInstanceId, jdbcType=VARCHAR},
        #{deleteReason, jdbcType=VARCHAR},
        #{tenantId, jdbcType=VARCHAR},
        #{name, jdbcType=VARCHAR},
        #{procState, jdbcType=INTEGER},
        #{sendUserName, jdbcType=VARCHAR},
        #{senderOrgId, jdbcType=VARCHAR},
        #{senderOrgName, jdbcType=VARCHAR},
        #{starter, jdbcType=VARCHAR},
        #{topProcessInstanceId, jdbcType=VARCHAR}
      )
  </insert>

  <insert id="bulkInsertHistoricProcessInstance" parameterType="java.util.List">
      insert into ${prefix}t_wf_hi_procinst (
        id_,
        proc_inst_id_,
        business_key_,
        proc_def_id_,
        start_time_,
        end_time_,
        duration_,
        start_user_id_,
        start_act_id_,
        end_act_id_,
        super_process_instance_id_,
        delete_reason_,
        tenant_id_,
        name_,
        proc_state,
        start_user_name,
        starter_org_id,
        starter_org_name,starter,top_process_instance_id_
      ) values
        <foreach collection="list" item="historicProcessInstance" index="index" separator=",">
          (#{historicProcessInstance.id ,jdbcType=VARCHAR},
           #{historicProcessInstance.processInstanceId, jdbcType=VARCHAR},
           #{historicProcessInstance.businessKey, jdbcType=VARCHAR},
           #{historicProcessInstance.processDefinitionId, jdbcType=VARCHAR},
           #{historicProcessInstance.startTime, jdbcType=TIMESTAMP},
           #{historicProcessInstance.endTime, jdbcType=TIMESTAMP},
           #{historicProcessInstance.durationInMillis ,jdbcType=BIGINT},
           #{historicProcessInstance.startUserId, jdbcType=VARCHAR},
           #{historicProcessInstance.startActivityId, jdbcType=VARCHAR},
           #{historicProcessInstance.endActivityId, jdbcType=VARCHAR},
           #{historicProcessInstance.superProcessInstanceId, jdbcType=VARCHAR},
           #{historicProcessInstance.deleteReason, jdbcType=VARCHAR},
           #{historicProcessInstance.tenantId, jdbcType=VARCHAR},
           #{historicProcessInstance.name, jdbcType=VARCHAR},
           #{historicProcessInstance.procState, jdbcType=INTEGER},
           #{historicProcessInstance.sendUserName, jdbcType=VARCHAR},
           #{historicProcessInstance.senderOrgId, jdbcType=VARCHAR},
           #{historicProcessInstance.senderOrgName, jdbcType=VARCHAR},
           #{historicProcessInstance.starter, jdbcType=VARCHAR},
           #{historicProcessInstance.topProcessInstanceId, jdbcType=VARCHAR}
           )
         </foreach>
  </insert>

  <insert id="bulkInsertHistoricProcessInstance_oracle" parameterType="java.util.List">
      INSERT ALL
        <foreach collection="list" item="historicProcessInstance" index="index">
          into ${prefix}t_wf_hi_procinst (
            id_,
            proc_inst_id_,
            business_key_,
            proc_def_id_,
            start_time_,
            end_time_,
            duration_,
            start_user_id_,
            start_act_id_,
            end_act_id_,
            super_process_instance_id_,
            delete_reason_,
            tenant_id_,
            name_,
            proc_state,
            start_user_name,
            starter_org_id,
            starter_org_name,starter,top_process_instance_id_
          ) VALUES
              (#{historicProcessInstance.id ,jdbcType=VARCHAR},
               #{historicProcessInstance.processInstanceId, jdbcType=VARCHAR},
               #{historicProcessInstance.businessKey, jdbcType=VARCHAR},
               #{historicProcessInstance.processDefinitionId, jdbcType=VARCHAR},
               #{historicProcessInstance.startTime, jdbcType=TIMESTAMP},
               #{historicProcessInstance.endTime, jdbcType=TIMESTAMP},
               #{historicProcessInstance.durationInMillis ,jdbcType=BIGINT},
               #{historicProcessInstance.startUserId, jdbcType=VARCHAR},
               #{historicProcessInstance.startActivityId, jdbcType=VARCHAR},
               #{historicProcessInstance.endActivityId, jdbcType=VARCHAR},
               #{historicProcessInstance.superProcessInstanceId, jdbcType=VARCHAR},
               #{historicProcessInstance.deleteReason, jdbcType=VARCHAR},
               #{historicProcessInstance.tenantId, jdbcType=VARCHAR},
               #{historicProcessInstance.name, jdbcType=VARCHAR},
               #{historicProcessInstance.procState, jdbcType=INTEGER},
               #{historicProcessInstance.sendUserName, jdbcType=VARCHAR},
               #{historicProcessInstance.senderOrgId, jdbcType=VARCHAR},
               #{historicProcessInstance.senderOrgName, jdbcType=VARCHAR},
               #{historicProcessInstance.starter, jdbcType=VARCHAR},
               #{historicProcessInstance.topProcessInstanceId, jdbcType=VARCHAR}
               )
       </foreach>
    SELECT * FROM dual
  </insert>

  <!-- HISTORIC PROCESS INSTANCE UPDATE -->

  <update id="updateHistoricProcessInstance" parameterType="org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntity">
    update ${prefix}t_wf_hi_procinst set
      proc_def_id_ = #{processDefinitionId, jdbcType=VARCHAR},
      business_key_ = #{businessKey, jdbcType=VARCHAR},
      start_time_ = #{startTime, jdbcType=TIMESTAMP},
      end_time_ = #{endTime, jdbcType=TIMESTAMP},
      duration_ = #{durationInMillis ,jdbcType=BIGINT},
      end_act_id_ = #{endActivityId, jdbcType=VARCHAR},
      delete_reason_ = #{deleteReason, jdbcType=VARCHAR},
      name_ = #{name, jdbcType=VARCHAR},
      proc_state =#{procState, jdbcType=INTEGER}
    where id_ = #{id}
  </update>

  <!-- HISTORIC PROCESS INSTANCE DELETE -->

  <delete id="deleteHistoricProcessInstance">
    delete from ${prefix}t_wf_hi_procinst where proc_inst_id_ = #{processInstanceId}
  </delete>

  <delete id="bulkDeleteHistoricProcessInstance" parameterType="java.util.Collection">
    delete from ${prefix}t_wf_hi_procinst where
     <foreach item="procInst" collection="list" index="index" separator=" or ">
        id_ = #{procInst.id, jdbcType=VARCHAR}
    </foreach>
  </delete>

  <!-- HISTORIC PROCESS INSTANCE RESULT MAP -->

  <resultMap id="historicProcessInstanceResultMap" type="org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntity">
    <id property="id" column="id_" jdbcType="VARCHAR" />
    <result property="processInstanceId" column="proc_inst_id_" jdbcType="VARCHAR" />
    <result property="businessKey" column="business_key_" jdbcType="VARCHAR"/>
    <result property="processDefinitionId" column="proc_def_id_" jdbcType="VARCHAR" />
    <result property="processDefinitionName" column="proc_def_name_" jdbcType="VARCHAR" />
    <result property="processDefinitionKey" column="proc_def_key_" jdbcType="VARCHAR" />
    <result property="processDefinitionVersion" column="proc_def_version_" jdbcType="INTEGER" />
    <result property="deploymentId" column="deployment_id_" jdbcType="VARCHAR" />
    <result property="startTime" column="start_time_" jdbcType="TIMESTAMP" />
    <result property="endTime" column="end_time_" jdbcType="TIMESTAMP" />
    <result property="durationInMillis" column="duration_" jdbcType="BIGINT" />
    <result property="startUserId" column="start_user_id_" jdbcType="VARCHAR" />
    <result property="startActivityId" column="start_act_id_" jdbcType="VARCHAR" />
    <result property="endActivityId" column="end_act_id_" jdbcType="VARCHAR" />
    <result property="superProcessInstanceId" column="super_process_instance_id_" jdbcType="VARCHAR" />
    <result property="deleteReason" column="delete_reason_" jdbcType="VARCHAR" />
    <result property="tenantId" column="tenant_id_" jdbcType="VARCHAR" />
    <result property="name" column="name_" jdbcType="VARCHAR" />
    <!--extend table columns 2013/5/6 by lw start -->
    <result property="procState" column="proc_state" jdbcType="VARCHAR" />
    <result property="sendUserName" column="start_user_name" jdbcType="VARCHAR" />
    <result property="senderOrgId" column="starter_org_id" jdbcType="VARCHAR" />
    <result property="senderOrgName" column="starter_org_name" jdbcType="VARCHAR" />
    <result property="starter" column="starter" jdbcType="VARCHAR" />
    <result property="topProcessInstanceId" column="top_process_instance_id_" jdbcType="VARCHAR" />
    <!--extend table columns 2013/5/6 by lw end -->
  </resultMap>

  <resultMap id="historicProcessInstanceAndVariablesResultMap" type="org.activiti.engine.impl.persistence.entity.HistoricProcessInstanceEntity">
    <id property="id" column="id_" jdbcType="VARCHAR" />
    <result property="processInstanceId" column="proc_inst_id_" jdbcType="VARCHAR" />
    <result property="businessKey" column="business_key_" jdbcType="VARCHAR"/>
    <result property="processDefinitionId" column="proc_def_id_" jdbcType="VARCHAR" />
    <result property="processDefinitionName" column="proc_def_name_" jdbcType="VARCHAR" />
    <result property="processDefinitionKey" column="proc_def_key_" jdbcType="VARCHAR" />
    <result property="processDefinitionVersion" column="proc_def_version_" jdbcType="INTEGER" />
    <result property="deploymentId" column="deployment_id_" jdbcType="VARCHAR" />
    <result property="startTime" column="start_time_" jdbcType="TIMESTAMP" />
    <result property="endTime" column="end_time_" jdbcType="TIMESTAMP" />
    <result property="durationInMillis" column="duration_" jdbcType="BIGINT" />
    <result property="startUserId" column="start_user_id_" jdbcType="VARCHAR" />
    <result property="startActivityId" column="start_act_id_" jdbcType="VARCHAR" />
    <result property="endActivityId" column="end_act_id_" jdbcType="VARCHAR" />
    <result property="superProcessInstanceId" column="super_process_instance_id_" jdbcType="VARCHAR" />
    <result property="deleteReason" column="delete_reason_" jdbcType="VARCHAR" />
    <result property="tenantId" column="tenant_id_" jdbcType="VARCHAR" />
    <result property="name" column="name_" jdbcType="VARCHAR" />
    <result property="procState" column="proc_state" jdbcType="VARCHAR" />
    <result property="sendUserName" column="start_user_name" jdbcType="VARCHAR" />
    <result property="senderOrgId" column="starter_org_id" jdbcType="VARCHAR" />
    <result property="senderOrgName" column="starter_org_name" jdbcType="VARCHAR" />
    <result property="starter" column="starter" jdbcType="VARCHAR" />
    <result property="topProcessInstanceId" column="top_process_instance_id_" jdbcType="VARCHAR" />
    <collection property="queryVariables" column="execution_id_" javaType="ArrayList" ofType="org.activiti.engine.impl.persistence.entity.HistoricVariableInstanceEntity">
      <id property="id" column="var_id_"/>
      <result property="name" column="var_name_" javaType="String" jdbcType="VARCHAR" />
      <result property="variableType" column="var_type_" javaType="org.activiti.engine.impl.variable.VariableType" jdbcType="VARCHAR" />
      <result property="revision" column="var_rev_" jdbcType="INTEGER" />
      <result property="processInstanceId" column="var_proc_inst_id_" jdbcType="VARCHAR" />
      <result property="executionId" column="var_execution_id_" jdbcType="VARCHAR" />
      <result property="taskId" column="var_task_id_" jdbcType="VARCHAR" />
      <result property="byteArrayRef" column="var_bytearray_id_" typeHandler="ByteArrayRefTypeHandler"/>
      <result property="doubleValue" column="var_double_" jdbcType="DOUBLE" />
      <result property="textValue" column="var_text_" jdbcType="VARCHAR" />
      <result property="textValue2" column="var_text2_" jdbcType="VARCHAR" />
      <result property="longValue" column="var_long_" jdbcType="BIGINT" />
    </collection>
  </resultMap>

  <!-- HISTORIC PROCESS INSTANCE SELECT -->

  <select id="selectHistoricProcessInstance" resultMap="historicProcessInstanceResultMap">
    select * from ${prefix}t_wf_hi_procinst where proc_inst_id_ = #{processInstanceId}
  </select>

  <select id="selectHistoricProcessInstanceIdsByProcessDefinitionId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultType="string">
    select id_
    from ${prefix}t_wf_hi_procinst
    where proc_def_id_ = #{parameter}
  </select>


  <select id="selectHistoricProcessInstancesByQueryCriteria" parameterType="org.activiti.engine.impl.HistoricProcessInstanceQueryImpl" resultMap="historicProcessInstanceResultMap">
    ${limitBefore}
    select RES.* ${limitBetween}, def.key_ as PROC_DEF_KEY_, def.name_ as PROC_DEF_NAME_, def.version_ as PROC_DEF_VERSION_, def.deployment_id_ as DEPLOYMENT_ID_
    <include refid="selectHistoricProcessInstancesByQueryCriteriaSql"/>
    ${orderBy}
    ${limitAfter}
  </select>

  <select id="selectHistoricProcessInstanceCountByQueryCriteria" parameterType="org.activiti.engine.impl.HistoricProcessInstanceQueryImpl" resultType="long">
    select count(distinct RES.id_)
    <include refid="selectHistoricProcessInstancesByQueryCriteriaSql"/>
  </select>

  <sql id="selectHistoricProcessInstancesByQueryCriteriaSql">
    from ${prefix}t_wf_hi_procinst RES
    left outer join ${prefix}t_wf_re_procdef def on RES.proc_def_id_ = def.id_
    <include refid="commonSelectHistoricProcessInstancesByQueryCriteriaSql"/>
  </sql>

  <select id="selectHistoricProcessInstancesWithVariablesByQueryCriteria" parameterType="org.activiti.engine.impl.HistoricProcessInstanceQueryImpl" resultMap="historicProcessInstanceAndVariablesResultMap">
    ${limitBefore}
    select RES.*, def.key_ as PROC_DEF_KEY_, def.name_ as PROC_DEF_NAME_, def.version_ as PROC_DEF_VERSION_, def.deployment_id_ as DEPLOYMENT_ID_,
    var.id_ as VAR_ID_,
    var.name_ as VAR_NAME_,
    var.var_type_ as VAR_TYPE_,
    var.rev_ as VAR_REV_,
    var.proc_inst_id_ as VAR_PROC_INST_ID_,
    var.execution_id_ as VAR_EXECUTION_ID_,
    var.task_id_ as VAR_TASK_ID_,
    var.bytearray_id_ as VAR_BYTEARRAY_ID_,
    var.double_ as VAR_DOUBLE_,
    var.text_ as VAR_TEXT_,
    var.text2_ as VAR_TEXT2_,
    var.last_updated_time_ as VAR_LAST_UPDATED_TIME_,
    var.long_ as VAR_LONG_
    ${limitBetween}
    <include refid="selectHistoricProcessInstancesWithVariablesByQueryCriteriaSql"/>
    ${orderBy}
    ${limitAfter}
  </select>

  <select id="selectHistoricProcessInstancesWithVariablesByQueryCriteria_mssql_or_db2" parameterType="org.activiti.engine.impl.HistoricProcessInstanceQueryImpl" resultMap="historicProcessInstanceAndVariablesResultMap">
    ${limitBefore}
    select distinct tempres_id_ as ID_,
    TEMPRES_BUSINESS_KEY_ as BUSINESS_KEY_,
    TEMPRES_PROC_DEF_ID_ as PROC_DEF_ID_,
    TEMPRES_START_TIME_ as START_TIME_,
    TEMPRES_END_TIME_ as END_TIME_,
    TEMPRES_DURATION_ as DURATION_,
    TEMPRES_START_USER_ID_ as START_USER_ID_,
    TEMPRES_START_ACT_ID_ as START_ACT_ID_,
    TEMPRES_END_ACT_ID_ as END_ACT_ID_,
    TEMPRES_SUPER_PROCESS_INSTANCE_ID_ as SUPER_PROCESS_INSTANCE_ID_,
    TEMPRES_DELETE_REASON_ as DELETE_REASON_,
    TEMPRES_NAME_ as NAME_,
    TEMPRES_TENANT_ID_ as TENANT_ID_,
    TEMPRES_PROC_DEF_KEY_ as PROC_DEF_KEY_,
    TEMPRES_PROC_DEF_NAME_ as PROC_DEF_NAME_,
    TEMPRES_PROC_DEF_VERSION_ as PROC_DEF_VERSION_,
    TEMPRES_DEPLOYMENT_ID_ as DEPLOYMENT_ID_,
    TEMPVAR_ID_ as VAR_ID_,
    TEMPVAR_NAME_ as VAR_NAME_,
    TEMPVAR_TYPE_ as VAR_TYPE_,
    TEMPVAR_REV_ as VAR_REV_,
    TEMPVAR_PROC_INST_ID_ as VAR_PROC_INST_ID_,
    TEMPVAR_EXECUTION_ID_ as VAR_EXECUTION_ID_,
    TEMPVAR_TASK_ID_ as VAR_TASK_ID_,
    TEMPVAR_BYTEARRAY_ID_ as VAR_BYTEARRAY_ID_,
    TEMPVAR_DOUBLE_ as VAR_DOUBLE_,
    TEMPVAR_TEXT_ as VAR_TEXT_,
    TEMPVAR_TEXT2_ as VAR_TEXT2_,
    TEMPVAR_LAST_UPDATED_TIME_ as VAR_LAST_UPDATED_TIME_,
    TEMPVAR_LONG_ as VAR_LONG_
    ${limitOuterJoinBetween}
    RES.ID_ as TEMPRES_ID_,
    RES.BUSINESS_KEY_ as TEMPRES_BUSINESS_KEY_,
    RES.PROC_DEF_ID_ as TEMPRES_PROC_DEF_ID_,
    RES.PROC_INST_ID_ as TEMPRES_PROC_INST_ID_,
    RES.START_TIME_ as TEMPRES_START_TIME_,
    RES.END_TIME_ as TEMPRES_END_TIME_,
    RES.DURATION_ as TEMPRES_DURATION_,
    RES.START_USER_ID_ as TEMPRES_START_USER_ID_,
    RES.START_ACT_ID_ as TEMPRES_START_ACT_ID_,
    RES.END_ACT_ID_ as TEMPRES_END_ACT_ID_,
    RES.SUPER_PROCESS_INSTANCE_ID_ as TEMPRES_SUPER_PROCESS_INSTANCE_ID_,
    RES.DELETE_REASON_ as TEMPRES_DELETE_REASON_,
    RES.NAME_ as TEMPRES_NAME_,
    RES.TENANT_ID_ as TEMPRES_TENANT_ID_,
    DEF.KEY_ as TEMPRES_PROC_DEF_KEY_,
    DEF.NAME_ as TEMPRES_PROC_DEF_NAME_,
    DEF.VERSION_ as TEMPRES_PROC_DEF_VERSION_,
    DEF.DEPLOYMENT_ID_ as TEMPRES_DEPLOYMENT_ID_,
    VAR.ID_ as TEMPVAR_ID_,
    VAR.NAME_ as TEMPVAR_NAME_,
    VAR.VAR_TYPE_ as TEMPVAR_TYPE_,
    VAR.REV_ as TEMPVAR_REV_,
    VAR.PROC_INST_ID_ as TEMPVAR_PROC_INST_ID_,
    VAR.EXECUTION_ID_ as TEMPVAR_EXECUTION_ID_,
    VAR.TASK_ID_ as TEMPVAR_TASK_ID_,
    VAR.BYTEARRAY_ID_ as TEMPVAR_BYTEARRAY_ID_,
    VAR.DOUBLE_ as TEMPVAR_DOUBLE_,
    VAR.TEXT_ as TEMPVAR_TEXT_,
    VAR.TEXT2_ as TEMPVAR_TEXT2_,
    VAR.LAST_UPDATED_TIME_ as TEMPVAR_LAST_UPDATED_TIME_,
    VAR.LONG_ as TEMPVAR_LONG_
    <include refid="selectHistoricProcessInstancesWithVariablesByQueryCriteriaSql"/>
    ${orderBy}
    ${limitAfter}
  </select>

  <sql id="selectHistoricProcessInstancesWithVariablesByQueryCriteriaSql">
    from ${prefix}t_wf_hi_procinst RES
    left outer join ${prefix}t_wf_re_procdef def on RES.proc_def_id_ = def.id_
    <if test="includeProcessVariables">
      left outer join ${prefix}t_wf_hi_varinst var on RES.proc_inst_id_ = var.execution_id_ and var.task_id_ is null
    </if>
    <include refid="commonSelectHistoricProcessInstancesByQueryCriteriaSql"/>
  </sql>

  <sql id="commonSelectHistoricProcessInstancesByQueryCriteriaSql">
    <foreach collection="queryVariableValues" index="index" item="queryVariableValue">
      inner join ${prefix}t_wf_hi_varinst  a${index} on RES.proc_inst_id_ = a${index}.proc_inst_id_
    </foreach>
    <foreach collection="orQueryObjects" index="orIndex" item="orQueryObject">
      <if test="orQueryObject.processKeyNotIn != null || orQueryObject.processDefinitionKey != null || orQueryObject.processDefinitionCategory != null || orQueryObject.processDefinitionName != null || orQueryObject.processDefinitionVersion != null || (orQueryObject.processDefinitionKeyIn != null &amp;&amp; orQueryObject.processDefinitionKeyIn.size() &gt; 0)">
        inner join ${prefix}t_wf_re_procdef def_or${orIndex} on RES.proc_def_id_ = def_or${orIndex}.id_
      </if>
      <if test="orQueryObject.deploymentId != null || (orQueryObject.deploymentIds != null &amp;&amp; orQueryObject.deploymentIds.size() &gt; 0)">
        left outer join ${prefix}t_wf_re_procdef deploy_p_or${orIndex} on RES.proc_def_id_ = deploy_p_or${orIndex}.id_
      </if>
      <if test="orQueryObject.queryVariableValues != null &amp;&amp; orQueryObject.queryVariableValues.size() &gt; 0">
        left outer join ${prefix}t_wf_hi_varinst a_or${orIndex} on RES.proc_inst_id_ = a_or${orIndex}.proc_inst_id_
      </if>
    </foreach>
    <if test="deploymentId != null || (deploymentIds != null &amp;&amp; deploymentIds.size() &gt; 0)">
      left outer join ${prefix}t_wf_re_procdef deploy_p on RES.proc_def_id_ = deploy_p.id_
    </if>
    <if test="withJobException">
      left outer join ${prefix}t_wf_ru_job job on RES.proc_inst_id_ = job.process_instance_id_
    </if>
    <where>
      <if test="processInstanceId != null">
        RES.proc_inst_id_ = #{processInstanceId}
      </if>
      <if test="processInstanceIds != null and !processInstanceIds.isEmpty()">
        and RES.proc_inst_id_ in
        <foreach item="item" index="index" collection="processInstanceIds" open="(" separator="," close=")">
          #{item}
        </foreach>
      </if>
      <if test="processDefinitionId != null">
        and RES.proc_def_id_ = #{processDefinitionId}
      </if>
      <if test="processDefinitionKey != null">
        and def.key_ = #{processDefinitionKey}
      </if>
      <if test="processDefinitionKeyIn != null &amp;&amp; processDefinitionKeyIn.size() &gt; 0">
        and def.key_ in
        <foreach item="definition" index="index" collection="processDefinitionKeyIn"
                 open="(" separator="," close=")">
          #{definition}
        </foreach>
      </if>
      <if test="processDefinitionVersion != null">
        and def.version_ = #{processDefinitionVersion}
      </if>
      <if test="processDefinitionCategory != null">
        and def.category_ = #{processDefinitionCategory}
      </if>
      <if test="processDefinitionName != null">
        and def.name_ like CONCAT('%',#{processDefinitionName},'%')
      </if>
      <if test="businessKey != null">
        and RES.business_key_ = #{businessKey}
      </if>
      <if test="deploymentId != null">
        and deploy_p.deployment_id_ = #{deploymentId}
      </if>
      <if test="deploymentIds != null &amp;&amp; deploymentIds.size() &gt; 0">
        and deploy_p.deployment_id_ in
        <foreach item="deployment" index="index" collection="deploymentIds"
                 open="(" separator="," close=")">
          #{deployment}
        </foreach>
      </if>
      <if test="startedBefore != null">
        and RES.start_time_ &lt;= #{startedBefore}
      </if>
      <if test="startedAfter != null">
        and RES.start_time_ &gt;= #{startedAfter}
      </if>
      <if test="finishedBefore != null">
        and RES.end_time_ &lt;= #{finishedBefore}
      </if>
      <if test="finishedAfter != null">
        and RES.end_time_ &gt;= #{finishedAfter}
      </if>
      <if test="processKeyNotIn != null">
        <foreach collection="processKeyNotIn" index="index" item="procDefKey">
        and def.key_ not like #{procDefKey}${wildcardEscapeClause}
      </foreach>
      </if>
      <if test="unfinished">
        and RES.end_time_ is null
      </if>
      <if test="finished">
        and RES.end_time_ is not null
      </if>
      <if test="notDeleted">
        and RES.delete_reason_ is null
      </if>
      <if test="deleted">
        and RES.delete_reason_ is not null
      </if>
      <if test="involvedUser != null">
        and (
          exists(select link.user_id_ from ${prefix}t_wf_hi_identitylink link where user_id_ = #{involvedUser} and link.proc_inst_id_ = RES.id_)
        )
      </if>
      <if test="startedBy != null">
        and RES.start_user_id_ = #{startedBy}
      </if>
      <if test="superProcessInstanceId != null">
        and RES.super_process_instance_id_ = #{superProcessInstanceId}
      </if>
      <if test="excludeSubprocesses">
        and RES.super_process_instance_id_ is null
      </if>
      <if test="tenantId != null">
        and RES.tenant_id_ = #{tenantId}
      </if>
      <if test="tenantIdLike != null">
        and RES.tenant_id_ like #{tenantIdLike}${wildcardEscapeClause}
      </if>
      <if test="withoutTenantId">
        and (RES.tenant_id_ = '' or RES.tenant_id_ is null)
      </if>
      <if test="procState != null">
      	and proc_state = #{procState}
      </if>
       <if test="name != null">
        and RES.name_ = #{name}
      </if>
      <if test="nameLike != null">
        and RES.name_ like CONCAT('%',#{nameLike},'%')
      </if>
        <if test="nameLikeIgnoreCase != null">
        and lower(RES.name_) like #{nameLikeIgnoreCase}${wildcardEscapeClause}
      </if>
      <foreach collection="queryVariableValues" index="index" item="queryVariableValue">
        <if test="queryVariableValue.name != null">
          <!-- Match-all variable-names when name is null -->
          and A${index}.name_= #{queryVariableValue.name}
        </if>
        <if test="!queryVariableValue.type.equals('null')">
        <!-- When operator is not-equals or type of value is null, type doesn't matter! -->
          and A${index}.var_type_ = #{queryVariableValue.type}
        </if>
        <if test="queryVariableValue.textValue != null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
          <choose>
            <when test="queryVariableValue.operator.equals('EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">
              and lower(A${index}.text_)
            </when>
            <otherwise>
              and A${index}.text_
            </otherwise>
          </choose>
          <choose>
            <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">LIKE</when>
            <otherwise><include refid="executionVariableOperator" /></otherwise>
          </choose>
          #{queryVariableValue.textValue}
          <choose>
              <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">${wildcardEscapeClause}</when>
          </choose>
        </if>
        <if test="queryVariableValue.textValue2 != null">
        and A${index}.text2_
        <choose>
          <when test="queryVariableValue.operator.equals('LIKE')">LIKE</when>
          <otherwise><include refid="executionVariableOperator" /></otherwise>
        </choose>
          #{queryVariableValue.textValue2}
          <choose>
              <when test="queryVariableValue.operator.equals('LIKE')">${wildcardEscapeClause}</when>
          </choose>
        </if>
        <if test="queryVariableValue.longValue != null">
        and A${index}.long_
        <include refid="executionVariableOperator" />
        #{queryVariableValue.longValue}
        </if>
        <if test="queryVariableValue.doubleValue != null">
        and A${index}.double_
        <include refid="executionVariableOperator" />
        #{queryVariableValue.doubleValue}
        </if>
        <!-- Null variable type -->
        <if test="queryVariableValue.textValue == null &amp;&amp; queryVariableValue.textValue2 == null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
          <choose>
          <when test="queryVariableValue.operator.equals('NOT_EQUALS')">
            and (A${index}.text_ is not null or A${index}.text2_ is not null or A${index}.long_ is not null or A${index}.double_ is not null or A${index}.bytearray_id_ is not null)
          </when>
          <otherwise>
            and A${index}.text_ is null and A${index}.text2_ is null and A${index}.long_ is null and A${index}.double_ is null and A${index}.bytearray_id_ is null
          </otherwise>
        </choose>
        </if>
      </foreach>
      <foreach item="orQueryObject" index="orIndex" collection="orQueryObjects">
        and
        <trim prefix="(" prefixOverrides="OR" suffix=")">
          <if test="orQueryObject.processInstanceId != null">
            RES.proc_inst_id_ = #{orQueryObject.processInstanceId}
          </if>
          <if test="orQueryObject.processInstanceIds != null and !orQueryObject.processInstanceIds.isEmpty()">
            or RES.proc_inst_id_ in
            <foreach item="item" index="index" collection="orQueryObject.processInstanceIds" open="(" separator="," close=")">
              #{item}
            </foreach>
          </if>
          <if test="orQueryObject.processDefinitionId != null">
            or RES.proc_def_id_ = #{orQueryObject.processDefinitionId}
          </if>
          <if test="orQueryObject.processDefinitionKey != null">
            or def_or${orIndex}.key_ = #{orQueryObject.processDefinitionKey}
          </if>
          <if test="orQueryObject.processDefinitionKeyIn != null &amp;&amp; orQueryObject.processDefinitionKeyIn.size() &gt; 0">
            or def_or${orIndex}.key_ in
            <foreach item="definition" index="index" collection="orQueryObject.processDefinitionKeyIn"
                     open="(" separator="," close=")">
              #{definition}
            </foreach>
          </if>
          <if test="orQueryObject.processDefinitionVersion != null">
            or def_or${orIndex}.version_ = #{orQueryObject.processDefinitionVersion}
          </if>
          <if test="orQueryObject.processDefinitionCategory != null">
            or def_or${orIndex}.category_ = #{orQueryObject.processDefinitionCategory}
          </if>
          <if test="orQueryObject.processDefinitionName != null">
            or def_or${orIndex}.name_ = #{orQueryObject.processDefinitionName}
          </if>
          <if test="orQueryObject.businessKey != null">
            or RES.business_key_ = #{orQueryObject.businessKey}
          </if>
          <if test="orQueryObject.deploymentId != null">
            or deploy_p_or${orIndex}.deployment_id_ = #{orQueryObject.deploymentId}
          </if>
          <if test="orQueryObject.deploymentIds != null &amp;&amp; orQueryObject.deploymentIds.size() &gt; 0">
            or deploy_p_or${orIndex}.deployment_id_ in
            <foreach item="deployment" index="index" collection="orQueryObject.deploymentIds"
                     open="(" separator="," close=")">
              #{deployment}
            </foreach>
          </if>
          <if test="orQueryObject.startedBefore != null">
            or RES.start_time_ &lt;= #{orQueryObject.startedBefore}
          </if>
          <if test="orQueryObject.startedAfter != null">
            or RES.start_time_ &gt;= #{orQueryObject.startedAfter}
          </if>
          <if test="orQueryObject.finishedBefore != null">
            or (RES.end_time_ is not null and RES.end_time_ &lt;= #{orQueryObject.finishedBefore})
          </if>
          <if test="orQueryObject.finishedAfter != null">
            or (RES.end_time_ is not null and RES.end_time_ &gt;= #{orQueryObject.finishedAfter})
          </if>
          <if test="orQueryObject.processKeyNotIn != null">
            or
            <trim prefix="(" prefixOverrides="AND" suffix=")">
              <foreach collection="orQueryObject.processKeyNotIn" index="index" item="procDefKey">
                and def_or${orIndex}.key_ not like #{procDefKey}${wildcardEscapeClause}
              </foreach>
            </trim>
          </if>
          <if test="orQueryObject.unfinished">
            or RES.end_time_ is null
          </if>
          <if test="orQueryObject.finished">
            or RES.end_time_ is not null
          </if>
          <if test="orQueryObject.notDeleted">
            or RES.delete_reason_ is null
          </if>
          <if test="orQueryObject.deleted">
            or RES.delete_reason_ is not null
          </if>
          <if test="orQueryObject.involvedUser != null">
            or (
              exists(select link.user_id_ from ${prefix}t_wf_hi_identitylink link where user_id_ = #{orQueryObject.involvedUser} and link.proc_inst_id_ = RES.id_)
            )
          </if>
          <if test="orQueryObject.startedBy != null">
            or RES.start_user_id_ = #{orQueryObject.startedBy}
          </if>
          <if test="orQueryObject.superProcessInstanceId != null">
            or RES.super_process_instance_id_ = #{orQueryObject.superProcessInstanceId}
          </if>
          <if test="orQueryObject.excludeSubprocesses">
            or RES.super_process_instance_id_ is null
          </if>
          <if test="orQueryObject.tenantId != null">
            or RES.tenant_id_ = #{orQueryObject.tenantId}
          </if>
          <if test="orQueryObject.tenantIdLike != null">
            or RES.tenant_id_ like #{orQueryObject.tenantIdLike}${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.withoutTenantId">
            or (RES.tenant_id_ = '' or RES.tenant_id_ is null)
          </if>
           <if test="orQueryObject.name != null">
            or RES.name_ = #{orQueryObject.name}
          </if>
          <if test="orQueryObject.nameLike != null">
            or RES.name_ like #{orQueryObject.nameLike}${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.nameLikeIgnoreCase != null">
            or lower(RES.name_) like #{orQueryObject.nameLikeIgnoreCase}${wildcardEscapeClause}
          </if>
          <foreach collection="orQueryObject.queryVariableValues" index="index" item="queryVariableValue">
            or
            <trim prefix="(" prefixOverrides="AND" suffix=")">
              <if test="queryVariableValue.name != null">
                <!-- Match-all variable-names when name is null -->
                and A_OR${orIndex}.name_= #{queryVariableValue.name}
              </if>
              <if test="!queryVariableValue.type.equals('null')">
              <!-- When operator is not-equals or type of value is null, type doesn't matter! -->
                and A_OR${orIndex}.var_type_ = #{queryVariableValue.type}
              </if>
              <if test="queryVariableValue.textValue != null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
                <choose>
                  <when test="queryVariableValue.operator.equals('EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">
                    and lower(A_OR${orIndex}.text_)
                  </when>
                  <otherwise>
                    and A_OR${orIndex}.text_
                  </otherwise>
                </choose>
                <choose>
                  <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">LIKE</when>
                  <otherwise><include refid="executionVariableOperator" /></otherwise>
                </choose>
                #{queryVariableValue.textValue}
                <choose>
                  <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">${wildcardEscapeClause}</when>
                </choose>
              </if>
              <if test="queryVariableValue.textValue2 != null">
                and A_OR${orIndex}.text2_
                <choose>
                  <when test="queryVariableValue.operator.equals('LIKE')">LIKE</when>
                  <otherwise><include refid="executionVariableOperator" /></otherwise>
                </choose>
                #{queryVariableValue.textValue2}
                <choose>
                  <when test="queryVariableValue.operator.equals('LIKE')">${wildcardEscapeClause}</when>
                </choose>
              </if>
              <if test="queryVariableValue.longValue != null">
                and A_OR${orIndex}.long_
                <include refid="executionVariableOperator" />
                #{queryVariableValue.longValue}
              </if>
              <if test="queryVariableValue.doubleValue != null">
                and A_OR${orIndex}.double_
                <include refid="executionVariableOperator" />
                #{queryVariableValue.doubleValue}
              </if>
              <!-- Null variable type -->
              <if test="queryVariableValue.textValue == null &amp;&amp; queryVariableValue.textValue2 == null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
                <choose>
                  <when test="queryVariableValue.operator.equals('NOT_EQUALS')">
                    and (A_OR${orIndex}.text_ is not null or A_OR${orIndex}.text2_ is not null or A_OR${orIndex}.long_ is not null or A_OR${orIndex}.double_ is not null or A_OR${orIndex}.bytearray_id_ is not null)
                  </when>
                  <otherwise>
                    and A_OR${orIndex}.text_ is null and A_OR${orIndex}.text2_ is null and A_OR${orIndex}.long_ is null and A_OR${orIndex}.double_ is null and A_OR${orIndex}.bytearray_id_ is null
                  </otherwise>
                </choose>
              </if>
            </trim>
          </foreach>
        </trim>
      </foreach>
      <if test="withJobException">
        and (job.exception_msg_ is not null or  job.exception_stack_id_ is not null)
      </if>
    </where>
  </sql>

  <sql id="executionVariableOperator">
    <choose>
      <when test="queryVariableValue.operator.equals('EQUALS')">=</when>
      <when test="queryVariableValue.operator.equals('EQUALS_IGNORE_CASE')">=</when>
      <when test="queryVariableValue.operator.equals('NOT_EQUALS')">&lt;&gt;</when>
      <when test="queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE')">&lt;&gt;</when>
      <when test="queryVariableValue.operator.equals('GREATER_THAN')">&gt;</when>
      <when test="queryVariableValue.operator.equals('GREATER_THAN_OR_EQUAL')">&gt;=</when>
      <when test="queryVariableValue.operator.equals('LESS_THAN')">&lt;</when>
      <when test="queryVariableValue.operator.equals('LESS_THAN_OR_EQUAL')">&lt;=</when>
   </choose>
  </sql>

   <select id="selectHistoricProcessInstanceByNativeQuery" parameterType="java.util.Map" resultMap="historicProcessInstanceResultMap">
   	<if test="resultType == 'LIST_PAGE'">
   		${limitBefore}
   	</if>
    ${sql}
    <if test="resultType == 'LIST_PAGE'">
    	${limitAfter}
    </if>
  </select>

  <select id="selectHistoricProcessInstanceByNativeQuery_mssql_or_db2" parameterType="java.util.Map" resultMap="historicProcessInstanceResultMap">
  	<if test="resultType == 'LIST_PAGE'">
        ${limitBeforeNativeQuery}
  	</if>
  	${sql}
    <if test="resultType == 'LIST_PAGE'">
  		${limitAfter}
  	</if>
  </select>

  <select id="selectHistoricProcessInstanceCountByNativeQuery" parameterType="java.util.Map" resultType="long">
    ${sql}
  </select>

  <!-- by lw -->
   <select id="selectAllHistoricProcessInstance" parameterType="string"  resultMap="historicProcessInstanceResultMap">
  	select id_, proc_inst_id_, business_key_, proc_def_id_, start_time_, end_time_, duration_, start_user_id_, start_act_id_, end_act_id_, super_process_instance_id_, delete_reason_, tenant_id_, name_, proc_state, proc_def_name, starter_org_name, starter_org_id, starter, top_process_instance_id_,
	(select assignee_user_name
	from(
	select tk.assignee_user_name,proc_inst_id_ from t_wf_hi_taskinst tk  order by tk.start_time_) tk
	where tk.proc_inst_id_=p.id_  limit 1) as START_USER_NAME from t_wf_hi_procinst p where find_in_set(
	proc_inst_id_, getprocchildlst((select t.top_process_instance_id_  from t_wf_hi_procinst t
	where t.proc_inst_id_=#{processInstanceId} limit 1)))
  </select>
</mapper>
