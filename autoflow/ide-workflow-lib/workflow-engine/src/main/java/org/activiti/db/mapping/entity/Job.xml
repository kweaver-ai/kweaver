<?xml version="1.0" encoding="UTF-8" ?> 
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> 
<mapper namespace="org.activiti.engine.impl.persistence.entity.JobEntity">

  <!-- JOB DELETE STATEMENTS-->

  <delete id="deleteJob" parameterType="org.activiti.engine.impl.persistence.entity.JobEntity">
    delete from ${prefix}t_wf_ru_job where id_ = #{id} and rev_ = #{revision}
  </delete>
  
  <delete id="bulkDeleteJob" parameterType="java.util.Collection">
    delete from ${prefix}t_wf_ru_job where
     <foreach item="job" collection="list" index="index" separator=" or ">
        id_ = #{job.id, jdbcType=VARCHAR}
    </foreach> 
  </delete>
  
  <delete id="deleteTimer" parameterType="org.activiti.engine.impl.persistence.entity.JobEntity">
    delete from ${prefix}t_wf_ru_job where id_ = #{id} and rev_ = #{revision}
  </delete>
  
  <delete id="bulkDeleteTimer" parameterType="java.util.Collection">
    delete from ${prefix}t_wf_ru_job where
     <foreach item="job" collection="list" index="index" separator=" or ">
        id_ = #{job.id, jdbcType=VARCHAR}
    </foreach> 
  </delete>
  
  <delete id="deleteMessage" parameterType="org.activiti.engine.impl.persistence.entity.JobEntity">
    delete from ${prefix}t_wf_ru_job where id_ = #{id} and rev_ = #{revision}
  </delete>
  
  <delete id="bulkDeleteMessage" parameterType="java.util.Collection">
    delete from ${prefix}t_wf_ru_job where
     <foreach item="job" collection="list" index="index" separator=" or ">
        id_ = #{job.id, jdbcType=VARCHAR}
    </foreach> 
  </delete>
  
  <!-- JOB UPDATE STATEMENTS -->
  <update id="updateJobTenantIdForDeployment" parameterType="java.util.Map">
    update ${prefix}t_wf_ru_job set
      tenant_id_ = #{tenantId, jdbcType=VARCHAR}
    where
      id_ in (
        SELECT J.id_ from ${prefix}t_wf_ru_job J
        inner join ${prefix}t_wf_re_procdef P on J.proc_def_id_  = P.id_
        inner join ${prefix}t_wf_re_deployment D on P.deployment_id_ = D.id_
        where D.id_ = #{deploymentId, jdbcType=VARCHAR}
      ) 
  </update>
  
  <update id="updateJobLockForAllJobs" parameterType="java.util.Map">
    update ${prefix}t_wf_ru_job set
      lock_owner_ = #{lockOwner, jdbcType=VARCHAR},
      lock_exp_time_ = #{lockExpirationTime, jdbcType=TIMESTAMP}
    where
      (retries_ &gt; 0)
      and (duedate_ is null or duedate_ &lt;= #{dueDate, jdbcType=TIMESTAMP})
      and (lock_owner_ is null)
      
	 <!--  and (
	  	    (EXECUTION_ID_ is null)
	  		or 
	  		(PI.SUSPENSION_STATE_ = 1)
      ) 
        -->
  </update>
    
  <!-- See http://stackoverflow.com/questions/4429319/you-cant-specify-target-table-for-update-in-from-clause
       Tested this on MySQL 5.6: does NOT use a temporary table (so good, performance) -->
  <update id="updateJobTenantIdForDeployment_mysql" parameterType="java.util.Map">
    update ${prefix}t_wf_ru_job set
      tenant_id_ = #{tenantId, jdbcType=VARCHAR}
    where
      id_ in (

          SELECT tempTask.tempId
          FROM (
                SELECT J.id_ as tempId
                FROM  ${prefix}t_wf_ru_job J
                inner join ${prefix}t_wf_re_procdef P on J.proc_def_id_  = P.id_
                inner join ${prefix}t_wf_re_deployment D on P.deployment_id_ = D.id_
                where D.id_ = #{deploymentId, jdbcType=VARCHAR}
                
        ) AS tempTask 

    )
  </update>
  
  <!-- JOB RESULTMAP (FOR TIMER AND MESSAGE) -->

  <resultMap id="jobResultMap" type="org.activiti.engine.impl.persistence.entity.JobEntity">
    <id property="id" column="id_" jdbcType="VARCHAR" />
    <result property="revision" column="rev_" jdbcType="INTEGER" />
    <result property="lockOwner" column="lock_owner_" jdbcType="VARCHAR" />
    <result property="lockExpirationTime" column="lock_exp_time_" jdbcType="TIMESTAMP" />
    <result property="exclusive" column="exclusive_" jdbcType="BOOLEAN" />
    <result property="executionId" column="execution_id_" jdbcType="VARCHAR" />
    <result property="processInstanceId" column="process_instance_id_" jdbcType="VARCHAR" />
    <result property="processDefinitionId" column="proc_def_id_" jdbcType="VARCHAR" />
    <result property="retries" column="retries_" jdbcType="INTEGER" />
    <result property="exceptionByteArrayRef" column="exception_stack_id_" typeHandler="ByteArrayRefTypeHandler" />
    <result property="exceptionMessage" column="exception_msg_" jdbcType="VARCHAR" />
    <result property="jobHandlerType" column="handler_type_" jdbcType="VARCHAR" />
    <result property="jobHandlerConfiguration" column="handler_cfg_" jdbcType="VARCHAR" />
    <result property="tenantId" column="tenant_id_" jdbcType="VARCHAR" />
    <discriminator javaType="string" column="type_">
      <case value="message" resultMap="messageResultMap"/> 
      <case value="timer" resultMap="timerResultMap"/> 
    </discriminator>
  </resultMap>

  <resultMap id="messageResultMap" type="org.activiti.engine.impl.persistence.entity.MessageEntity" extends="jobResultMap"/>

  <resultMap id="timerResultMap" type="org.activiti.engine.impl.persistence.entity.TimerEntity" extends="jobResultMap">
    <result property="duedate" column="duedate_" jdbcType="TIMESTAMP" />
    <result property="repeat" column="repeat_" jdbcType="VARCHAR" />
  </resultMap>

  <!-- JOB SELECT (FOR TIMER AND MESSAGE) -->  

  <select id="selectJob" parameterType="string" resultMap="jobResultMap">
    select * from ${prefix}t_wf_ru_job where id_ = #{id}
  </select>

  <select id="selectNextJobsToExecute" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
  	${limitBefore}
    select 
    	RES.* ${limitBetween}
    from ${prefix}t_wf_ru_job RES
    	LEFT OUTER JOIN ${prefix}t_wf_ru_execution pi ON pi.id_ = RES.process_instance_id_
    where (RES.retries_ &gt; 0)
      and (RES.duedate_ is null or RES.duedate_ &lt;= #{parameter, jdbcType=TIMESTAMP})
      and (RES.lock_owner_ is null or RES.lock_exp_time_ &lt;= #{parameter, jdbcType=TIMESTAMP})
	    and (
	  	    (RES.execution_id_ is null)
	  		  or 
	  		  (pi.suspension_state_ = 1)
      )  
    ${limitAfter}	    
  </select>
  
  <select id="selectNextTimerJobsToExecute" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
    ${limitBefore}
    select 
      RES.* ${limitBetween}
    from ${prefix}t_wf_ru_job RES
      LEFT OUTER JOIN ${prefix}t_wf_ru_execution pi ON pi.id_ = RES.process_instance_id_
    where (RES.retries_ &gt; 0)
      and (RES.duedate_ is null or RES.duedate_ &lt;= #{parameter, jdbcType=TIMESTAMP})
      and (RES.lock_owner_ is null or RES.lock_exp_time_ &lt;= #{parameter, jdbcType=TIMESTAMP})
      and type_ = 'timer'
      and (
          (RES.execution_id_ is null)
          or 
          (pi.suspension_state_ = 1)
      )  
    ${limitAfter}     
  </select>
  
  <select id="selectAsyncJobsDueToExecute" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
    ${limitBefore}
    select 
      RES.* ${limitBetween}
    from ${prefix}t_wf_ru_job RES
      LEFT OUTER JOIN ${prefix}t_wf_ru_execution pi ON pi.id_ = RES.process_instance_id_
    where RES.retries_ &gt; 0
       and ( 
        (RES.duedate_ is not null and RES.duedate_ &lt;= #{parameter, jdbcType=TIMESTAMP} and RES.lock_exp_time_ is null)
        or 
        (RES.lock_exp_time_ is not null and RES.lock_exp_time_ &lt;= #{parameter, jdbcType=TIMESTAMP})
      )
      and type_ = 'message'
      and (
          (RES.execution_id_ is null)
          or 
          (pi.suspension_state_ = 1)
      )  
    ${limitAfter}     
  </select>
  
  <select id="selectJobsByLockOwner" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
  	${limitBefore}
    select 
    	RES.* ${limitBetween}
    from ${prefix}t_wf_ru_job RES
    where (RES.lock_owner_ = #{parameter, jdbcType=VARCHAR})
    order by id_ <!-- Need to have some definitive ordering to have a correct check in place during job fetching -->
    ${limitAfter}	    
  </select>   
  
  <select id="selectExclusiveJobsToExecute" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
  	${limitBefore}
    select RES.* ${limitBetween}
    from ${prefix}t_wf_ru_job RES
    where (retries_ &gt; 0)
      and (duedate_ is null or duedate_ &lt;= #{parameter.now, jdbcType=TIMESTAMP})
      and (lock_owner_ is null or lock_exp_time_ &lt;= #{parameter.now, jdbcType=TIMESTAMP})
      and (exclusive_ = TRUE)
      and (process_instance_id_ = #{parameter.pid})
    ${limitAfter}
  </select>
  
  <select id="selectExclusiveJobsToExecute_integerBoolean" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
  	${limitBefore}
    select RES.* ${limitBetween}
    from ${prefix}t_wf_ru_job RES
    where (retries_ &gt; 0)
      and (duedate_ is null or duedate_ &lt;= #{parameter.now, jdbcType=TIMESTAMP})
      and (lock_owner_ is null or lock_exp_time_ &lt;= #{parameter.now, jdbcType=TIMESTAMP})
      and (exclusive_ = 1)
      and (process_instance_id_ = #{parameter.pid})
    ${limitAfter}   
  </select>
  
  <select id="selectJobsByConfiguration" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
      select * from ${prefix}t_wf_ru_job
      where handler_type_ = #{parameter.handlerType}
      and handler_cfg_ like  #{parameter.handlerConfiguration}
  </select>

  <select id="selectJobsByExecutionId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
    select *
    from ${prefix}t_wf_ru_job J
    where J.execution_id_ = #{parameter}
  </select>
  
   <select id="selectJobByTypeAndProcessDefinitionKeyNoTenantId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
    select J.*
    from ${prefix}t_wf_ru_job J
    inner join ${prefix}t_wf_re_procdef P on J.proc_def_id_ = P.id_
    where J.handler_type_ = #{parameter.handlerType}
    and P.key_ = #{parameter.processDefinitionKey}
    and (P.tenant_id_ = ''  or P.tenant_id_ is null)
  </select>
  
  <select id="selectJobByTypeAndProcessDefinitionKeyAndTenantId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
    select J.*
    from ${prefix}t_wf_ru_job J
    inner join ${prefix}t_wf_re_procdef P on J.proc_def_id_ = P.id_
    where J.handler_type_ = #{parameter.handlerType}
    and P.key_ = #{parameter.processDefinitionKey}
    and P.tenant_id_ = #{parameter.tenantId}
  </select>
  
  <select id="selectJobByTypeAndProcessDefinitionId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
    select J.*
    from ${prefix}t_wf_ru_job J
    where J.handler_type_ = #{parameter.handlerType}
    and J.proc_def_id_ = #{parameter.processDefinitionId}
  </select>
  
  <select id="selectJobByQueryCriteria" parameterType="org.activiti.engine.impl.JobQueryImpl" resultMap="jobResultMap">
  	${limitBefore}
    select RES.* ${limitBetween}
    <include refid="selectJobByQueryCriteriaSql"/>
    ${orderBy}
    ${limitAfter}
  </select>

  <select id="selectJobCountByQueryCriteria" parameterType="org.activiti.engine.impl.JobQueryImpl" resultType="long">
    select count(distinct RES.id_)
    <include refid="selectJobByQueryCriteriaSql"/>
  </select>
  
  <sql id="selectJobByQueryCriteriaSql">
    from ${prefix}t_wf_ru_job RES
    <if test="executable">
        LEFT OUTER JOIN ${prefix}t_wf_ru_execution pi ON pi.id_ = RES.process_instance_id_
    </if>
    <where>
      <if test="id != null">
        RES.id_ = #{id}
      </if>
      <if test="processInstanceId != null">
        and RES.process_instance_id_ = #{processInstanceId}
      </if>
      <if test="executionId != null">
        and RES.execution_id_ = #{executionId}
      </if>
      <if test="processDefinitionId != null">
        and RES.proc_def_id_ = #{processDefinitionId}
      </if>
      <if test="retriesLeft">
        and RES.retries_ &gt; 0
      </if>
      <if test="noRetriesLeft">
        and RES.retries_ &lt;= 0
      </if>
      <if test="executable">
        and (RES.retries_ &gt; 0)
        and (RES.duedate_ is null or RES.duedate_ &lt;= #{now, jdbcType=TIMESTAMP})
        and (
            (RES.execution_id_ is null)
            or 
            (pi.suspension_state_ = 1)
      )
      </if>
      <if test="onlyTimers">
        and RES.type_ = 'timer'
      </if>
      <if test="onlyMessages">
        and RES.type_ = 'message'
      </if>
      <if test="duedateHigherThan != null">
        and RES.duedate_ &gt; #{duedateHigherThan}
      </if>
      <if test="duedateLowerThan != null">
        and RES.duedate_ &lt; #{duedateLowerThan}
      </if>
      <if test="duedateHigherThanOrEqual != null">
        and RES.duedate_ &gt;= #{duedateHigherThanOrEqual}
      </if>
      <if test="duedateLowerThanOrEqual != null">
        and RES.duedate_ &lt;= #{duedateLowerThanOrEqual}
      </if>
      <if test="withException">
      	and (RES.exception_msg_ is not null or RES.exception_stack_id_ is not null)
      </if>
      <if test="exceptionMessage">
      	and RES.exception_msg_ = #{exceptionMessage}
      </if>
      <if test="tenantId != null">
        and RES.tenant_id_ = #{tenantId}
      </if>
      <if test="tenantIdLike != null">
        and RES.tenant_id_ like #{tenantIdLike}${wildcardEscapeClause}
      </if>
      <if test="withoutTenantId">
        and (RES.tenant_id_ = '' or RES.tenant_id_ is null)
      </if>
    </where>
  </sql>

  <!-- TIMER INSERT -->
  
  <insert id="insertTimer" parameterType="org.activiti.engine.impl.persistence.entity.TimerEntity">
    insert into ${prefix}t_wf_ru_job (
            id_,
            rev_,
            type_,
            lock_owner_,
            lock_exp_time_,
            exclusive_,
            execution_id_,
            process_instance_id_,
            proc_def_id_,
            retries_,
            exception_stack_id_,
            exception_msg_,
            duedate_,
            repeat_,
            handler_type_,
            handler_cfg_,
            tenant_id_)
    values (#{id, jdbcType=VARCHAR},
            1,
            'timer',
            #{lockOwner, jdbcType=VARCHAR},
            #{lockExpirationTime, jdbcType=TIMESTAMP},
            #{exclusive, jdbcType=BOOLEAN},
            #{executionId, jdbcType=VARCHAR},
            #{processInstanceId, jdbcType=VARCHAR},
            #{processDefinitionId, jdbcType=VARCHAR},
            #{retries, jdbcType=INTEGER},
            #{exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
            #{exceptionMessage, jdbcType=VARCHAR},
            #{duedate, jdbcType=TIMESTAMP},
            #{repeat, jdbcType=VARCHAR},
            #{jobHandlerType, jdbcType=VARCHAR},
            #{jobHandlerConfiguration, jdbcType=VARCHAR},
            #{tenantId, jdbcType=VARCHAR}
    )
  </insert>

  <insert id="bulkInsertTimer" parameterType="java.util.List">
    INSERT INTO ${prefix}t_wf_ru_job (
            id_,
            rev_,
            type_,
            lock_owner_,
            lock_exp_time_,
            exclusive_,
            execution_id_,
            process_instance_id_,
            proc_def_id_,
            retries_,
            exception_stack_id_,
            exception_msg_,
            duedate_,
            repeat_,
            handler_type_,
            handler_cfg_,
            tenant_id_) VALUES
    <foreach collection="list" item="job" index="index" separator=","> 
        (#{job.id, jdbcType=VARCHAR},
         1,
         #{job.jobType, jdbcType=VARCHAR},
         #{job.lockOwner, jdbcType=VARCHAR},
         #{job.lockExpirationTime, jdbcType=TIMESTAMP},
         #{job.exclusive, jdbcType=BOOLEAN},
         #{job.executionId, jdbcType=VARCHAR},
         #{job.processInstanceId, jdbcType=VARCHAR},
         #{job.processDefinitionId, jdbcType=VARCHAR},
         #{job.retries, jdbcType=INTEGER},
         #{job.exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
         #{job.exceptionMessage, jdbcType=VARCHAR},
         #{job.duedate, jdbcType=TIMESTAMP},
         #{job.repeat, jdbcType=VARCHAR},
         #{job.jobHandlerType, jdbcType=VARCHAR},
         #{job.jobHandlerConfiguration, jdbcType=VARCHAR},
         #{job.tenantId, jdbcType=VARCHAR})
    </foreach>
  </insert>

  <insert id="bulkInsertTimer_oracle" parameterType="java.util.List">
    INSERT ALL 
    <foreach collection="list" item="job" index="index"> 
      INTO ${prefix}t_wf_ru_job (
              id_,
              rev_,
              type_,
              lock_owner_,
              lock_exp_time_,
              exclusive_,
              execution_id_,
              process_instance_id_,
              proc_def_id_,
              retries_,
              exception_stack_id_,
              exception_msg_,
              duedate_,
              repeat_,
              handler_type_,
              handler_cfg_,
              tenant_id_) VALUES
          (#{job.id, jdbcType=VARCHAR},
           1,
           #{job.jobType, jdbcType=VARCHAR},
           #{job.lockOwner, jdbcType=VARCHAR},
           #{job.lockExpirationTime, jdbcType=TIMESTAMP},
           #{job.exclusive, jdbcType=BOOLEAN},
           #{job.executionId, jdbcType=VARCHAR},
           #{job.processInstanceId, jdbcType=VARCHAR},
           #{job.processDefinitionId, jdbcType=VARCHAR},
           #{job.retries, jdbcType=INTEGER},
           #{job.exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
           #{job.exceptionMessage, jdbcType=VARCHAR},
           #{job.duedate, jdbcType=TIMESTAMP},
           #{job.repeat, jdbcType=VARCHAR},
           #{job.jobHandlerType, jdbcType=VARCHAR},
           #{job.jobHandlerConfiguration, jdbcType=VARCHAR},
           #{job.tenantId, jdbcType=VARCHAR})
    </foreach>
    SELECT * FROM dual
  </insert>

  <!-- TIMER UPDATE -->

  <update id="updateTimer" parameterType="org.activiti.engine.impl.persistence.entity.TimerEntity">
    update ${prefix}t_wf_ru_job
    <set>
       rev_ =  #{revisionNext, jdbcType=INTEGER},
       lock_exp_time_ = #{lockExpirationTime, jdbcType=TIMESTAMP},
       lock_owner_ = #{lockOwner, jdbcType=VARCHAR},
       retries_ = #{retries, jdbcType=INTEGER},
       exception_stack_id_ = #{exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
       exception_msg_ = #{exceptionMessage, jdbcType=VARCHAR},
       duedate_ = #{duedate, jdbcType=TIMESTAMP}
    </set>
    where id_= #{id, jdbcType=VARCHAR}
      and rev_ = #{revision, jdbcType=INTEGER}
  </update>
  
  <!-- TIMER SELECT -->
  
  <select id="selectUnlockedTimersByDuedate" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
    select RES.*
    from ${prefix}t_wf_ru_job RES
    LEFT OUTER JOIN ${prefix}t_wf_ru_execution pi ON pi.id_ = RES.process_instance_id_
    where (RES.type_ = 'timer')
      and (RES.duedate_ &lt; #{parameter, jdbcType=TIMESTAMP})
      and (RES.lock_owner_ is null or RES.lock_exp_time_ &lt; #{parameter, jdbcType=TIMESTAMP})
      and (RES.retries_  &gt; 0)
      and (
        (RES.execution_id_ is null)
        or 
        (pi.suspension_state_ = 1)
      )
    order by duedate_
  </select>

  <select id="selectUnlockedTimersByDuedate_oracle" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject"
          resultMap="jobResultMap">
    select RES.*
    from ${prefix}t_wf_ru_job RES
    LEFT OUTER JOIN ${prefix}t_wf_ru_execution pi ON pi.id_ = RES.process_instance_id_
    where (RES.type_ = 'timer')
    and (RES.duedate_ &lt; #{parameter, jdbcType=TIMESTAMP})
    and (NVL(RES.lock_owner_, 'UNDEF')='UNDEF' OR RES.lock_exp_time_ &lt; #{parameter, jdbcType=TIMESTAMP})
    and (RES.retries_ &gt; 0)
    and (NVL(RES.execution_id_ , 'UNDEF')='UNDEF' OR
         exists (select 1 from ${prefix}t_wf_ru_execution pi where pi.id_ =
    RES.process_instance_id_ and pi.suspension_state_ = 1)
    )
    order by duedate_
  </select>

  <select id="selectTimersByExecutionId" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject" resultMap="jobResultMap">
    select * 
    from ${prefix}t_wf_ru_job
    where (retries_ &gt; 0)
      and (type_ = 'timer')
      and (execution_id_ = #{parameter})
  </select>
  

  <!-- MESSAGE INSERT -->

  <insert id="bulkInsertMessage" parameterType="java.util.List">
    INSERT INTO ${prefix}t_wf_ru_job (
        id_,
        rev_,
        type_,
        lock_owner_,
        lock_exp_time_,
        exclusive_,
        execution_id_,
        process_instance_id_,
        proc_def_id_,
        duedate_,
        retries_,
        exception_stack_id_,
        exception_msg_,
        handler_type_,
        handler_cfg_,
        tenant_id_) VALUES
    <foreach collection="list" item="job" index="index" separator=",">
      (#{job.id, jdbcType=VARCHAR},
       1,
       #{job.jobType, jdbcType=VARCHAR},
       #{job.lockOwner, jdbcType=VARCHAR},
       #{job.lockExpirationTime, jdbcType=TIMESTAMP},
       #{job.exclusive, jdbcType=BOOLEAN},
       #{job.executionId, jdbcType=VARCHAR},
       #{job.processInstanceId, jdbcType=VARCHAR},
       #{job.processDefinitionId, jdbcType=VARCHAR},
       #{job.duedate, jdbcType=TIMESTAMP},
       #{job.retries, jdbcType=INTEGER},
       #{job.exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
       #{job.exceptionMessage, jdbcType=VARCHAR},
       #{job.jobHandlerType, jdbcType=VARCHAR},
       #{job.jobHandlerConfiguration, jdbcType=VARCHAR},
       #{job.tenantId, jdbcType=VARCHAR})
    </foreach>
  </insert>

  <insert id="bulkInsertMessage_oracle" parameterType="java.util.List">
    INSERT ALL 
    <foreach collection="list" item="job" index="index">
      INTO ${prefix}t_wf_ru_job (
          id_,
          rev_,
          type_,
          lock_owner_,
          lock_exp_time_,
          exclusive_,
          execution_id_,
          process_instance_id_,
          proc_def_id_,
          duedate_,
          retries_,
          exception_stack_id_,
          exception_msg_,
          handler_type_,
          handler_cfg_,
          tenant_id_) VALUES
      (#{job.id, jdbcType=VARCHAR},
       1,
       #{job.jobType, jdbcType=VARCHAR},
       #{job.lockOwner, jdbcType=VARCHAR},
       #{job.lockExpirationTime, jdbcType=TIMESTAMP},
       #{job.exclusive, jdbcType=BOOLEAN},
       #{job.executionId, jdbcType=VARCHAR},
       #{job.processInstanceId, jdbcType=VARCHAR},
       #{job.processDefinitionId, jdbcType=VARCHAR},
       #{job.duedate, jdbcType=TIMESTAMP},
       #{job.retries, jdbcType=INTEGER},
       #{job.exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
       #{job.exceptionMessage, jdbcType=VARCHAR},
       #{job.jobHandlerType, jdbcType=VARCHAR},
       #{job.jobHandlerConfiguration, jdbcType=VARCHAR},
       #{job.tenantId, jdbcType=VARCHAR})
    </foreach>
    SELECT * FROM dual
  </insert>

  <insert id="insertMessage" parameterType="org.activiti.engine.impl.persistence.entity.MessageEntity">
    insert into ${prefix}t_wf_ru_job (
            id_,
            rev_,
            type_,
            lock_owner_,
            lock_exp_time_,
            exclusive_,
            execution_id_,
            process_instance_id_,
            proc_def_id_,
            duedate_,
            retries_,
            exception_stack_id_,
            exception_msg_,
            handler_type_,
            handler_cfg_,
            tenant_id_)
    values (#{id, jdbcType=VARCHAR},
            1,
            'message',
            #{lockOwner, jdbcType=VARCHAR},
            #{lockExpirationTime, jdbcType=TIMESTAMP},
            #{exclusive, jdbcType=BOOLEAN},
            #{executionId, jdbcType=VARCHAR},
            #{processInstanceId, jdbcType=VARCHAR},
            #{processDefinitionId, jdbcType=VARCHAR},
            #{duedate, jdbcType=TIMESTAMP},
            #{retries, jdbcType=INTEGER},
            #{exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
            #{exceptionMessage, jdbcType=VARCHAR},
            #{jobHandlerType, jdbcType=VARCHAR},
            #{jobHandlerConfiguration, jdbcType=VARCHAR},
            #{tenantId, jdbcType=VARCHAR}
    )
  </insert>
  
  <!-- MESSAGE UPDATE -->
  
  <update id="updateMessage" parameterType="org.activiti.engine.impl.persistence.entity.MessageEntity">
    update ${prefix}t_wf_ru_job
    <set>
       rev_ =  #{revisionNext, jdbcType=INTEGER},
       lock_exp_time_ = #{lockExpirationTime, jdbcType=TIMESTAMP},
       lock_owner_ = #{lockOwner, jdbcType=VARCHAR},
       retries_ = #{retries, jdbcType=INTEGER},
       exception_stack_id_ = #{exceptionByteArrayRef, typeHandler=ByteArrayRefTypeHandler},
       exception_msg_ = #{exceptionMessage, jdbcType=VARCHAR},
       duedate_ = #{duedate, jdbcType=TIMESTAMP}
    </set>
    where id_= #{id, jdbcType=VARCHAR}
      and rev_ = #{revision, jdbcType=INTEGER}
  </update>
  
  <update id="unacquireJob" parameterType="org.activiti.engine.impl.db.ListQueryParameterObject">
    update ${prefix}t_wf_ru_job
    set duedate_ = #{dueDate,jdbcType=TIMESTAMP}, lock_owner_ = null, lock_exp_time_ = null
    where id_ = #{id,jdbcType=VARCHAR}
  </update>

</mapper>
