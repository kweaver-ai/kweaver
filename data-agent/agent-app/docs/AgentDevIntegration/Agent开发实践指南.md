# Agent开发实践指南

## 概述

本指南为外部系统接入ADP（Agent统一开发平台）提供完整的实践指导，帮助开发者通过API方式使用ADP创建的Agent搭建对话平台。

## 1. 系统对接概述

### 1.1 对接目标
- 通过API方式调用ADP创建的Agent
- 搭建完整的对话平台界面
- 支持多轮对话、文件问答、会话管理等核心功能

### 1.2 对接前提条件
- ADP平台已部署并运行
- 在ADP平台创建并发布Agent为API
- 获取应用账户Token用于API调用

### 1.3 对接架构
```
外部系统 → ADP API Gateway → Agent-App → Agent Factory → Agent Executor
```

## 2. 账户与鉴权体系

### 2.1 鉴权方式对比
todo:区分融合部署

#### 2.1.1 内部系统对接（如AF）
- **用户Token**: 使用普通用户Token，有效期较短
- **应用Token**: 使用应用账户Token，有效期较长
- **特点**: 账户体系统一，支持两种Token方式

#### 2.1.2 外部系统对接
- **应用Token**: 必须使用应用账户Token
- **创建方式**: 在ADP平台创建应用账户，生成长期有效的Token
- **特点**: 独立账户体系，仅支持应用Token

### 2.2 Token获取与使用

#### 应用Token创建流程
1. 登录ADP管理平台
2. 进入"应用管理"页面
3. 创建新的应用账户
4. 生成应用Token
5. 配置Token有效期和权限

#### 请求头配置
```http
Authorization: Bearer {app_token}
Content-Type: application/json
```

## 3. Agent导入与发布

### 3.1 Agent创建方式

#### 3.1.1 界面创建
1. 登录ADP平台
2. 进入"Agent管理"
3. 创建新Agent
4. 配置Agent参数（模型、工具、技能等）
5. 测试Agent功能
6. 发布为API

todo:（可以参考DIP数据智能体配置与操作指导手册）

#### 3.1.2 接口导入
- **适用场景**: 批量导入、系统初始化
- **接口地址**: `POST /api/agent/import`
- **请求参数**:
```json
{
  "agents": [
    {
      "name": "智能客服助手",
      "description": "提供客户服务支持",
      "model_config": {},
      "tools": [],
      "skills": [],
      "prompt_template": ""
    }
  ]
}
```
todo:仅导入agent配置，
todo:增加 Agent 更新步骤
### 3.2 Agent发布配置
界面发布

#### 发布参数
```json
{
  "publish_type": "api",
  "access_control": "public | private",
  "rate_limit": 1000,
  "quota_limit": 10000
}
```

## 4. Agent API对接详解

### 4.1 基础接口信息

#### 4.1.1 基础URL
```
http://{adp_host}/api/agent-app/v1/app/{app_key}/api/chat/completion
```
todo:使用新路由
#### 4.1.2 请求方法
- **POST**: 所有对话请求
- **GET**: 会话管理相关

### 4.2 请求参数详解

#### 4.2.1 基础参数
```json
{
  "agent_id": "string",           // Agent唯一标识，必填
  "agent_version": "string",      // Agent版本，默认"latest"
  "stream": true,                 // 是否启用流式响应，默认true
  "inc_stream": true,             // 是否启用增量流式，默认true
  "conversation_id": "string",    // 会话ID，用于多轮对话
  "temporary_area_id": "string",  // 临时区ID，用于文件问答
  "query": "string"               // 用户查询内容，必填
}
```

#### 4.2.2 文件问答参数

todo:详细解释文件上传
```json
{
  "temp_files": [
    {
      "id": "file_001",           // 文件ID，必填
      "name": "document.pdf",     // 文件名称
      "type": "doc"               // 文件类型：doc/image/audio等
    }
  ]
}
```

#### 4.2.3 高级配置参数
```json
{
  "chat_mode": "normal | deep_thinking",  // 对话模式
  "llm_config": {                         // 大模型配置
    "temperature": 0.7,
    "max_tokens": 2000
  },
  "data_source": {                        // 数据源配置
    "kg": [],
    "doc": []
  }
}
```

### 4.3 会话管理机制

#### 4.3.1 自动会话创建
- **首次对话**: 不提供`conversation_id`，系统自动创建并返回
- **继续对话**: 使用返回的`conversation_id`维护上下文
- **会话复用**: 合理复用现有会话，避免创建过多会话

#### 4.3.2 会话生命周期
- **创建**: 首次对话时自动创建
- **维护**: 系统自动维护会话状态和上下文

### 4.4 流式与非流式响应

#### 4.4.1 流式响应（推荐）
- **适用场景**: 实时对话、长文本生成
- **技术实现**: Server-Sent Events (SSE)
- **优势**: 实时反馈、用户体验好

#### 4.4.2 非流式响应
- **适用场景**: 简单问答、批量处理
- **技术实现**: 标准HTTP响应
- **优势**: 实现简单、适合同步处理

## 5. 响应结果处理
todo: 和上面第四章合并

### 5.1 响应格式

#### 5.1.1 流式响应格式
```
event: message
data: {"conversation_id": "string", "user_message_id": "string", "assistant_message_id": "string", "message": {...}}

event: end
data: {}
```

#### 5.1.2 非流式响应格式
```json
{
  "conversation_id": "string",
  "user_message_id": "string",
  "assistant_message_id": "string",
  "message": {
    "content": {
      "final_answer": {
        "answer": {
          "text": "最终答案文本"
        }
      },
      "middle_answer": [
        {
          "progress": [
            {
              "step": 1,
              "description": "处理步骤描述",
              "status": "completed"
            }
          ]
        }
      ]
    }
  }
}
```

### 5.2 结果处理策略

#### 5.2.1 仅需要最终结果
```javascript
// 直接使用final_answer中的内容
const finalAnswer = response.message.content.final_answer.answer.text;
```

#### 5.2.2 需要展示对话过程
```javascript
// 使用middle_answer中的progress字段
const progress = response.message.content.middle_answer[0].progress;
progress.forEach(step => {
  console.log(`${step.step}: ${step.description} - ${step.status}`);
});
```

#### 5.2.3 渐进式展示
```javascript
function handleStreamResponse(data) {
  if (data.middle_answer && data.middle_answer.length > 0) {
    // 展示处理进度
    showProgress(data.middle_answer[0].progress);
  }

  if (data.final_answer) {
    // 展示最终结果
    showFinalResult(data.final_answer);
  }
}
```

## 6. 核心功能实现

### 6.1 对话界面实现

todo:使用的接口需要给出在具体的接口文档的位置

#### 6.1.1 界面布局设计
如果需要构建对话界面，可以采用典型的分栏布局设计。左侧边栏用于显示会话列表，右侧主区域用于展示对话内容和输入界面。

在界面设计中，建议包含以下关键组件：
- **会话列表区域**：显示当前用户的所有会话，支持点击切换
- **消息显示区域**：展示多轮对话的历史记录和实时响应
- **输入控制区域**：包含文本输入框、发送按钮和终止按钮

这种布局设计能够提供良好的用户体验，让用户能够方便地管理多个对话会话，同时保持对话的连贯性。

#### 6.1.2 会话列表管理
如果需要实现会话列表管理，可以通过调用会话列表接口来获取用户的对话历史。建议在应用启动时加载会话列表，并在用户创建新对话时及时更新列表。

在实现会话列表时，可以考虑以下功能：
- 显示会话标题和最后更新时间
- 支持按时间排序和搜索过滤
- 实现会话删除和重命名功能
- 显示未读消息提示

通过良好的会话列表管理，用户可以快速找到之前的对话记录，提高使用效率。

### 6.2 文件问答实现

#### 6.2.1 文件上传流程
如果需要支持文件问答功能，建议采用以下标准流程：

1. **文件选择与上传**：用户通过界面选择需要分析的文件，系统将文件上传到临时存储区域
2. **临时区创建**：为上传的文件创建临时区域，获取唯一的临时区ID
3. **对话引用**：在发起对话时，将临时区ID和文件信息包含在请求参数中
4. **文档分析**：Agent基于上传的文件内容进行智能问答和分析

这种流程设计确保了文件的安全存储和高效处理，同时为用户提供了便捷的文件问答体验。

#### 6.2.2 临时区管理机制
临时区管理是文件问答功能的核心。如果需要实现临时区管理，可以通过临时区相关接口来完成。

todo:应用账户能否创建临时区文件夹



### 6.3 对话恢复实现

todo:恢复接口需要会话id，所有需要在调用agent api 接口前， 调用会话初始化接口，拿到对于的会话id
#### 6.3.1 状态检测机制
如果需要支持对话恢复功能，建议实现会话状态的检测机制。

在状态检测中，主要关注以下场景：
- 检测会话是否处于处理中状态
- 识别因网络中断或页面刷新导致的对话中断
- 记录中断时的消息ID和会话上下文

通过准确的状态检测，可以为用户提供无缝的对话恢复体验。

#### 6.3.2 恢复机制设计
对话恢复功能需要在检测到中断后能够继续之前的对话。如果需要实现此功能，可以通过以下方式：

- 在恢复请求中包含中断时的会话ID和消息ID
- 系统基于中断点继续生成后续响应
- 保持对话上下文的连贯性
- 在界面中清晰提示恢复状态

这种恢复机制确保了用户在意外中断后能够继续之前的对话，提升了产品的可用性。

### 6.4 对话终止实现

#### 6.4.1 终止机制设计
如果需要提供对话终止功能，可以通过前端的中断控制机制来实现。当用户点击终止按钮时，系统应该能够立即停止正在进行的对话处理。

在终止机制设计中，建议考虑以下要点：
- 使用请求取消机制来终止正在进行的API调用
- 在界面中提供清晰的终止状态反馈
- 确保终止操作不会影响其他功能
- 记录终止操作的相关日志

通过可靠的终止机制，用户可以随时控制对话的进行，避免不必要的等待时间。

## 7. 错误处理与监控

### 7.1 错误分类处理

#### 7.1.1 客户端错误（4xx）
如果需要处理客户端错误，建议根据不同的错误码采取相应的处理策略。对于400错误码，通常表示请求参数存在问题，需要检查请求参数的完整性和格式。对于401错误码，表明认证失败，需要验证Token的有效性和权限配置。403错误码表示权限不足，需要检查应用账户的权限设置。404错误码则表示请求的资源不存在，需要确认Agent ID等资源标识的正确性。

#### 7.1.2 服务端错误（5xx）
服务端错误通常表示系统内部出现问题。如果需要处理这类错误，建议实现适当的重试机制。可以根据错误类型和业务场景判断是否需要进行重试，对于临时性的服务不可用错误，可以设置合理的重试间隔和次数限制。

### 7.2 重试机制

#### 7.2.1 指数退避重试
如果需要实现重试机制，可以考虑采用指数退避策略。这种策略会在每次重试时逐渐增加等待时间，避免对服务端造成过大的压力。在实现重试时，建议设置合理的最大重试次数，避免无限重试导致资源浪费。

### 7.3 监控与日志

#### 7.3.1 性能监控
如果需要监控API调用性能，可以记录每个API调用的耗时和状态。建议将性能数据上报到监控系统，便于分析系统性能和发现潜在问题。在监控指标中，可以包括响应时间、成功率、错误率等关键指标。

## 8. 性能优化建议

### 8.1 前端优化

#### 8.1.1 流式响应处理优化
如果需要优化流式响应处理，可以考虑实现高效的增量更新机制。在接收到流式数据时，应该只更新发生变化的部分，避免频繁的界面重绘。同时，建议实现连接错误的重连机制，在网络中断时能够自动恢复连接，确保用户体验的连续性。

#### 8.1.2 本地存储优化
如果需要优化本地存储，可以考虑使用本地缓存来存储会话数据。可以为每个会话设置独立的缓存键，并配置适当的过期时间。在实现本地缓存时，需要注意数据的一致性和存储空间的合理使用。

### 8.2 后端调用优化

#### 8.2.1 请求参数优化
如果需要优化后端调用性能，可以从请求参数入手。建议合理控制历史记录的长度，避免过长的上下文导致处理性能下降。同时，选择合适的对话模式，根据实际需求在普通模式和深度思考模式之间进行选择，平衡响应速度和处理深度的关系。

## 9. 安全考虑

### 9.1 API安全

#### 9.1.1 Token安全管理
- 应用Token定期轮换
- 实现Token刷新机制
- 避免在前端硬编码Token

#### 9.1.2 请求安全
- 使用HTTPS加密传输
- 实现请求签名验证
- 设置合理的API调用频率限制

### 9.2 数据安全

#### 9.2.1 敏感信息处理
如果需要处理敏感信息，建议实现适当的数据脱敏机制。可以对用户输入中的敏感信息进行识别和替换，例如银行卡号、身份证号、手机号等个人信息。在实现脱敏时，需要确保脱敏规则的准确性和完整性，避免敏感信息泄露。

## 10. 部署与运维

### 10.1 环境配置

#### 10.1.1 开发环境
如果需要配置开发环境，建议为不同的环境设置独立的配置参数。开发环境通常使用本地服务地址和测试用的App Key和Token，而生产环境则需要使用正式的服务地址和经过验证的认证信息。

#### 10.1.2 生产环境
- 配置负载均衡
- 设置监控告警
- 实现日志收集

### 10.2 故障排查

#### 10.2.1 常见问题
1. **Token失效**: 检查Token有效期和权限
2. **Agent未发布**: 确认Agent已发布为API
3. **网络超时**: 检查网络连接和超时设置
4. **会话丢失**: 检查会话存储和恢复机制

#### 10.2.2 调试工具
如果需要实现调试工具，可以开发专门的调试界面或工具来辅助问题排查。调试工具应该能够显示详细的请求和响应信息，包括请求参数、响应状态码、响应数据等。通过调试工具，可以更快速地定位和解决对接过程中遇到的问题。

## 11. 最佳实践总结

### 11.1 开发实践
- 使用应用Token进行系统级别对接
- 实现完整的错误处理和重试机制
- 合理使用流式响应提升用户体验
- 实现会话状态管理和恢复机制

### 11.2 运维实践
- 监控API调用性能和成功率
- 定期轮换应用Token
- 设置合理的限流和配额
- 建立完善的日志和告警系统

### 11.3 安全实践
- 使用HTTPS加密所有通信
- 实现敏感信息脱敏处理
- 设置访问频率限制
- 定期进行安全审计

---

*最后更新: 2025-11-18*
*版本: 1.0.0*