# Starter pipeline
#

trigger:
  branches:
    include:
      - MISSION
      - feature/*
      - hotfix/*
      - release/*


parameters:
  - name: TRIVY_EXIT_CODE
    displayName: trivy exit code
    type: number
    default: 1
    values:
      - 0
      - 1
  - name: SKIP_SONARQUBE
    displayName: skip sonarqube
    type: number
    default: 0
    values:
      - 0
      - 1

variables:
  - group: global-dip
  - name: imageRegistry
    value: acr.aishu.cn
  - name: imageRepository
    value: dip/agent-executor
  - name: isMisson
    value: $[startsWith(variables['Build.SourceBranch'], 'refs/heads/MISSION')]
  - name: buildImage
    value: "acr.aishu.cn/dip/py.build:3.10.18-20251030"
  - name: lintReportName
    value: lint_report.xml
  - name: utReportName
    value: '*.xml'
  - name: coverageReportName
    value: coverage.xml
  - name: chartRepo
    value: "https://acr.aishu.cn/api/chartrepo/dip/charts"
  - name: chartName
    value: "agent-executor"
  - name: yqImage
    value: "acr.aishu.cn/public/mikefarah/yq:4.26.1"


resources:
  containers:
    - container: dotnet
      endpoint: acr.aishu.cn
      image: wing-biz/euop/dotnet-runtime:3.1
  repositories:
    - repository: templatesAlias
      type: git
      name: ONE-Architecture\Yaml-Templates
      ref: "refs/heads/main"
    - repository: arPipelineTemplates
      type: git
      name: AnyRobot\PipelineTemplates
      ref: "refs/heads/develop"

stages:
  - stage: InitVariable
    displayName: 初始化
    jobs:
      - job: InitVariable
        pool: anydata-centos7.7-x86_64
        workspace:
          clean: all
        steps:
          - checkout: self
          - bash: |
              set -ex
              VERSION=`cat VERSION`

              gitCommit="$(git rev-parse --short HEAD 2>/dev/null)"

              # 处理分支名称，将/替换为-
              # 从refs/heads/feature/12345中提取feature/12345，然后将/替换为-
              BRANCH_NAME=$(echo $(Build.SourceBranch) | sed 's#refs/heads/##' | tr '/' '-')
              CURRENT_TAG="${VERSION}-${BRANCH_NAME}.git-${gitCommit}.$(Build.BuildId)"
              LATEST_TAG="${VERSION}-${BRANCH_NAME}.git-${gitCommit}"
              # if [ $(isMisson) = True ]; then
              #     CURRENT_TAG="${VERSION}.${gitCommit}.$(Build.BuildId)"
              #     LATEST_TAG="${VERSION}.${gitCommit}"
              # fi


              set +x
              echo "##vso[task.setvariable variable=VERSION;isoutput=true]$VERSION"
              set +x
              echo "##vso[task.setvariable variable=CURRENT_TAG;isoutput=true]$CURRENT_TAG"
              set +x
              echo "##vso[task.setvariable variable=LATEST_TAG;isoutput=true]$LATEST_TAG"

            name: MyOutputVar

  # - stage: CodeCheck
  #   dependsOn:
  #     - InitVariable
  #   displayName: 代码检查
  #   jobs:
      # - job: CodeCheck
      #   displayName: 代码检查
      #   workspace:
      #     clean: all
      #   pool:
      #     name: anydata-centos7.7-x86_64
      #     demands:
      #       - Agent.OSArchitecture -equals X64
      #       - Agent.OS -equals Linux
      #       - docker
      #   steps:
      #     - checkout: self
      #     - task: Bash@3
      #       displayName: 单元测试
      #       inputs:
      #         targetType: inline
      #         script: |
      #           #!/usr/bin/env bash
      #           # todo 补充 UT
      #           set -ex

      #           docker run --rm \
      #                 -v $(pwd):/agent-executor \
      #                 $(buildImage) bash -c "


      #             cd /agent-executor

      #             uv sync --only-group test 
                  

      #             mkdir -p /agent-executor/report
      #             uv run coverage_ut.py 2>&1
      #             mv coverage.xml report/$(coverageReportName)
      #             mv coverage_result report
      #             uv run pylint coverage_ut.py --output=report/$(lintReportName) --exit-zero

      #             "

      #     - task: PublishBuildArtifacts@1 # 将相应目录publish到artifact
      #       inputs:
      #         PathtoPublish: "$(Build.SourcesDirectory)/report"
      #         ArtifactName: CodeCheckReportFiles
      #     - template: sonarqube-setps.yml@arPipelineTemplates
      #       parameters:
      #         SKIP_SONARQUBE: ${{ parameters.SKIP_SONARQUBE }}

      #     - task: Post-Bash@3
      #       inputs:
      #         targetType: inline
      #         script: |
      #           rm -rf $(Build.SourcesDirectory)
      #           ls -lah $(Agent.BuildDirectory)


      # - job: UploadReport
      #   displayName: 上传检查报告
      #   container: dotnet
      #   dependsOn: CodeCheck
      #   pool:
      #     name: anydata-centos7.7-x86_64
      #     demands:
      #       - Agent.OSArchitecture -equals X64
      #       - Agent.OS -equals Linux
      #       - docker
      #   steps:
      #     - task: DownloadBuildArtifacts@0
      #       inputs:
      #         artifactName: CodeCheckReportFiles
      #         downloadPath: $(Build.BinariesDirectory)

      #     - task: PublishTestResults@2
      #       displayName: 发布Lint测试报告
      #       inputs:
      #         testResultsFormat: "JUnit"
      #         testResultsFiles: "$(Build.BinariesDirectory)/CodeCheckReportFiles/$(lintReportName)"
      #         testRunTitle: "Lint Result"
      #         failTaskOnFailedTests: false
      #     - task: BuildQualityChecks@8 # 此行保持一致 Lint卡点
      #       displayName: Quality Gate Lint # 此行保持一致
      #       inputs:
      #         checkWarnings: true # 此行保持一致
      #         warningFailOption: "fixed"
      #         warningThreshold: "1000"
      #         showStatistics: false
      #         evaluateTaskWarnings: false
      #         evaluateFileWarnings: true
      #         warningFilesFolder: "$(Build.BinariesDirectory)/CodeCheckReportFiles"
      #         warningFiles: "**/$(lintReportName)" # 此行保持一致
      #         warningFileFilters: '/^.+<\/failure>.*?$/'
      #         warningFilesArtifact: "CodeCheckReportFiles"

      #     - task: PublishTestResults@2
      #       displayName: 发布UT测试报告
      #       inputs:
      #         testResultsFormat: "JUnit"
      #         testResultsFiles: "$(Build.BinariesDirectory)/CodeCheckReportFiles/coverage_result/*.xml"
      #         testRunTitle: "UT Result"
      #         failTaskOnFailedTests: false

      #     - task: BuildQualityChecks@8 # 此行保持一致 # UT卡点
      #       displayName: Quality Gate UT # 此行保持一致
      #       inputs:
      #         checkWarnings: true # 此行保持一致
      #         warningFailOption: "fixed"
      #         warningThreshold: "1000"
      #         showStatistics: false
      #         evaluateTaskWarnings: false
      #         evaluateFileWarnings: true
      #         warningFilesFolder: "$(Build.BinariesDirectory)/CodeCheckReportFiles"
      #         warningFiles: "**/$(utReportName)" # 此行保持一致
      #         warningFileFilters: '/^.+<\/failure>.*?$/'
      #         warningFilesArtifact: "CodeCheckReportFiles"

      #     - task: PublishCodeCoverageResults@1
      #       displayName: 发布UT测试覆盖率报告
      #       inputs:
      #         codeCoverageTool: "Cobertura"
      #         summaryFileLocation: "$(Build.BinariesDirectory)/CodeCheckReportFiles/$(coverageReportName)"

      #     - task: BuildQualityChecks@8 # 此行保持一致 代码覆盖率卡点
      #       displayName: Quality Gate Coverage # 此行保持一致
      #       inputs:
      #         coverageType: "lines" # 代表行覆盖率
      #         coverageFailOption: "fixed"
      #         checkCoverage: true # 此行保持一致
      #         coverageThreshold: "0" # 代码覆盖率卡点阈值

      #     - task: Post-Bash@3
      #       inputs:
      #         targetType: inline
      #         script: |
      #           rm -rf $(Build.SourcesDirectory)
      #           ls -lah $(Agent.BuildDirectory)

  - stage: BuildImage
    displayName: 镜像构建
    dependsOn:
      - InitVariable
      # - CodeCheck
    variables:
      VERSION: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.VERSION']]
      CURRENT_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.CURRENT_TAG']]
      LATEST_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.LATEST_TAG']]
    jobs:
      - job: BuildImage
        displayName: 镜像构建
        workspace:
          clean: all
        strategy:
          matrix:
            amd64:
              ARCH_TYPE: amd64
              pool: anydata-centos7.7-x86_64
            arm64:
              ARCH_TYPE: arm64
              pool: anydata-centos7-arm
          maxParallel: 2
        pool:
          name: $[ variables['pool'] ]
          demands:
            - Agent.OS -equals Linux
            - docker
        steps:
          - checkout: self
          - task: Bash@3
            displayName: 更新提交时间信息
            inputs:
              targetType: inline
              script: |
                #!/usr/bin/env bash
                set -ex
                
                # 获取当前时间，格式：2025年10月31日10:46:05
                CURRENT_TIME=$(date '+%Y年%m月%d日%H:%M:%S')
                
                # 获取最新的git commit信息
                GIT_COMMIT_HASH=$(git rev-parse HEAD)
                GIT_COMMIT_SHORT=$(git rev-parse --short HEAD)
                GIT_AUTHOR=$(git log -1 --pretty=format:'%an <%ae>')
                GIT_DATE=$(git log -1 --pretty=format:'%ad' --date=format:'%Y年%m月%d日%H:%M:%S')
                # 使用%B获取完整的commit message（包括标题和正文）
                GIT_MESSAGE=$(git log -1 --pretty=format:'%B')
                
                # 更新last_commit_info.txt文件
                {
                  echo "Updated at: $CURRENT_TIME"
                  echo "Updated by: Azure DevOps Pipeline (Build #$(Build.BuildId))"
                  echo ""
                  echo "Latest Git Commit:"
                  echo "Commit: $GIT_COMMIT_HASH ($GIT_COMMIT_SHORT)"
                  echo "Author: $GIT_AUTHOR"
                  echo "Date:   $GIT_DATE"
                  echo "Message: $GIT_MESSAGE"
                } > last_commit_info.txt
                
                echo "✓ Updated last_commit_info.txt with build time and git commit info"
                cat last_commit_info.txt
                
          - task: Docker@2
            displayName: 登录容器仓库
            inputs:
              containerRegistry: "ACRDockerRegistry"
              command: "login"
          - task: Bash@3
            name: BuildImageTask
            displayName: 镜像构建
            inputs:
              targetType: inline
              script: |
                #!/usr/bin/env bash
                set -ex
                
                echo "ARCH_TYPE is: $ARCH_TYPE"  # Debug: Print ARCH_TYPE value

                cp ~/.ssh/id_rsa id_rsa
                echo machine devops.aishu.cn login DIP password $(System.AccessToken) > .netrc
                
                CURRENT_IMAGE="$(imageRegistry)/$(imageRepository):${CURRENT_TAG}.$(ARCH_TYPE)"
                LATEST_IMAGE="$(imageRegistry)/$(imageRepository):${LATEST_TAG}.$(ARCH_TYPE)"


                docker build --force-rm --no-cache --pull -t ${CURRENT_IMAGE} -f ./build/Dockerfile \
                    --build-arg buildImage=$(buildImage) --build-arg ARCH_TYPE="${ARCH_TYPE}" .

                set +x
                echo "##vso[task.setvariable variable=CURRENT_IMAGE;isoutput=true]$CURRENT_IMAGE"
                set +x
                echo "##vso[task.setvariable variable=LATEST_IMAGE;isoutput=true]$LATEST_IMAGE"


          # - template: scan-image-step.yml@templatesAlias
          #   parameters:
          #     imageName: $(BuildImageTask.CURRENT_IMAGE)
          #     exitCode: ${{ parameters.TRIVY_EXIT_CODE }}
          #     scanTimeout: 10m

          - task: Bash@3
            displayName: 推送镜像
            inputs:
              targetType: inline
              script: |
                #!/usr/bin/env bash
                set -ex


                docker tag $(BuildImageTask.CURRENT_IMAGE) $(BuildImageTask.LATEST_IMAGE)
                docker push $(BuildImageTask.CURRENT_IMAGE)
                docker push $(BuildImageTask.LATEST_IMAGE)
                docker rmi $(BuildImageTask.CURRENT_IMAGE) $(BuildImageTask.LATEST_IMAGE)

          - task: Post-Bash@3
            inputs:
              targetType: inline
              script: |
                rm -rf $(Build.SourcesDirectory)
                ls -lah $(Agent.BuildDirectory)

  - stage: MakeManifest
    displayName: 制作多架构镜像
    dependsOn:
      - InitVariable
      - BuildImage
    variables:
      CURRENT_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.CURRENT_TAG']]
      LATEST_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.LATEST_TAG']]
    jobs:
      - job: MakeManifest
        displayName: 制作多架构镜像
        workspace:
          clean: all
        pool:
          name: anydata-centos7.7-x86_64
          demands:
            - Agent.OSArchitecture -equals X64
            - Agent.OS -equals Linux
            - docker
        steps:
          - task: Docker@2
            displayName: 登录容器仓库
            inputs:
              containerRegistry: ACRDockerRegistry
              command: login

          - task: Bash@3
            displayName: 制作多架构镜像
            inputs:
              targetType: inline
              script: |
                #!/usr/bin/env bash
                set -ex


                CURRENT_IMAGE="$(imageRegistry)/$(imageRepository):${CURRENT_TAG}"
                LATEST_IMAGE="$(imageRegistry)/$(imageRepository):${LATEST_TAG}"

                docker manifest create --amend ${CURRENT_IMAGE} ${CURRENT_IMAGE}.amd64 ${CURRENT_IMAGE}.arm64
                docker manifest create --amend ${LATEST_IMAGE} ${LATEST_IMAGE}.amd64 ${LATEST_IMAGE}.arm64

                docker manifest push -p ${CURRENT_IMAGE}
                docker manifest push -p ${LATEST_IMAGE}

          - task: Post-Bash@3
            inputs:
              targetType: inline
              script: |
                rm -rf $(Build.SourcesDirectory)
                ls -lah $(Agent.BuildDirectory)

  - stage: ChartPush
    displayName: Chart构建
    dependsOn:
      - InitVariable
    variables:
        CURRENT_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.CURRENT_TAG']]
        LATEST_TAG: $[stageDependencies.InitVariable.InitVariable.outputs['MyOutputVar.LATEST_TAG']]
    jobs:
      - job: ChartPush
        displayName: Chart构建
        workspace:
          clean: all
        pool:
          name: anydata-centos7.7-x86_64
          demands:
            - Agent.OSArchitecture -equals X64
            - Agent.OS -equals Linux
            - docker
        steps:
          - checkout: self
          - task: Bash@3
            displayName: Chart构建
            inputs:
              targetType: inline
              script: |
                #!/usr/bin/env
                set -ex

                chmod 777 -R $(pwd)/helm
                docker run --rm \
                      -v $(pwd)/helm:/chart \
                      --entrypoint='' \
                      $(yqImage) sh -c "
                  set -ex

                  yq eval -i '.image.registry = \"$(imageRegistry)\"' /chart/$(chartName)/values.yaml
                  yq eval -i '.image.repository = \"$(imageRepository)\"' /chart/$(chartName)/values.yaml
                  yq eval -i '.image.tag = \"${LATEST_TAG}\"' /chart/$(chartName)/values.yaml

                  yq eval -i '.name = \"$(chartName)\"' /chart/$(chartName)/Chart.yaml
                  yq eval -i '.appVersion = \"${CURRENT_TAG}\"' /chart/$(chartName)/Chart.yaml
                  sed -i 's/\"version\": .*/\"version\": \"${CURRENT_TAG}\",/g' /chart/$(chartName)/_componentMeta.json

                  yq eval -i '.version = \"${CURRENT_TAG}\"' /chart/$(chartName)/Chart.yaml
                  cd /chart && tar -czf $(chartName)-${CURRENT_TAG}.tar.gz $(chartName)

                  yq eval -i '.version = \"${LATEST_TAG}\"' /chart/$(chartName)/Chart.yaml
                  cd /chart && tar -czf $(chartName)-${LATEST_TAG}.tar.gz $(chartName)
                  "

                cd helm
                curlOptions="-s -u $(registry.username):$(registry.password) -H \"Content-Type:multipart/form-data\""
                curl ${curlOptions} -F "chart=@$(chartName)-${CURRENT_TAG}.tar.gz;type=application/x-compressed-tar" -X POST "$(chartRepo)"
                curl ${curlOptions} -F "chart=@$(chartName)-${LATEST_TAG}.tar.gz;type=application/x-compressed-tar" -X POST "$(chartRepo)"

          - task: Post-Bash@3
            inputs:
              targetType: inline
              script: |
                rm -rf $(Build.SourcesDirectory)
                ls -lah $(Agent.BuildDirectory)
